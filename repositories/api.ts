/* tslint:disable */
/* eslint-disable */
/**
 * IM CXM APIs Documentation
 * IM CXM OpenApi description
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Adventure model
 * @export
 * @interface Adventure
 */
export interface Adventure {
    /**
     *
     * @type {number}
     * @memberof Adventure
     */
    'id'?: number;
    /**
     *
     * @type {number}
     * @memberof Adventure
     */
    'region_id'?: number;
    /**
     *
     * @type {string}
     * @memberof Adventure
     */
    'country_name'?: string;
    /**
     *
     * @type {string}
     * @memberof Adventure
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Adventure
     */
    'highlights'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof Adventure
     */
    'testimonial'?: string;
    /**
     *
     * @type {string}
     * @memberof Adventure
     */
    'client_name'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Adventure
     */
    'slide_urls'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof Adventure
     */
    'map_url'?: string;
}
/**
 * Adventure Resource model
 * @export
 * @interface AdventureResource
 */
export interface AdventureResource {
    /**
     *
     * @type {number}
     * @memberof AdventureResource
     */
    'id'?: number;
    /**
     *
     * @type {AdventureResourceRegion}
     * @memberof AdventureResource
     */
    'region'?: AdventureResourceRegion;
    /**
     *
     * @type {string}
     * @memberof AdventureResource
     */
    'country_name'?: string;
    /**
     *
     * @type {string}
     * @memberof AdventureResource
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof AdventureResource
     */
    'highlights'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof AdventureResource
     */
    'testimonial'?: string;
    /**
     *
     * @type {string}
     * @memberof AdventureResource
     */
    'client_name'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof AdventureResource
     */
    'slides'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof AdventureResource
     */
    'map_url'?: string;
}
/**
 *
 * @export
 * @interface AdventureResourceRegion
 */
export interface AdventureResourceRegion {
    /**
     *
     * @type {number}
     * @memberof AdventureResourceRegion
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof AdventureResourceRegion
     */
    'name'?: string;
}
/**
 * Asset model
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     *
     * @type {number}
     * @memberof Asset
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    'location'?: string;
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    'extension'?: string;
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    'url'?: string;
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    'thumb'?: string;
}
/**
 * Asset Resource model
 * @export
 * @interface AssetResource
 */
export interface AssetResource {
    /**
     *
     * @type {number}
     * @memberof AssetResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof AssetResource
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof AssetResource
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof AssetResource
     */
    'location'?: string;
    /**
     *
     * @type {string}
     * @memberof AssetResource
     */
    'extension'?: string;
    /**
     *
     * @type {string}
     * @memberof AssetResource
     */
    'url'?: string;
    /**
     *
     * @type {string}
     * @memberof AssetResource
     */
    'thumb'?: string;
}
/**
 * Block model
 * @export
 * @interface Block
 */
export interface Block {
    /**
     *
     * @type {number}
     * @memberof Block
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    'name'?: string;
    /**
     *
     * @type {number}
     * @memberof Block
     */
    'category_id'?: number;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    'image'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof Block
     */
    'structure'?: Array<object>;
}
/**
 * Block page model
 * @export
 * @interface BlockPage
 */
export interface BlockPage {
    /**
     *
     * @type {number}
     * @memberof BlockPage
     */
    'page_id'?: number;
    /**
     *
     * @type {number}
     * @memberof BlockPage
     */
    'block_id'?: number;
    /**
     *
     * @type {object}
     * @memberof BlockPage
     */
    'props'?: object;
    /**
     *
     * @type {number}
     * @memberof BlockPage
     */
    'order'?: number;
}
/**
 * Block page Resource model
 * @export
 * @interface BlockPageResource
 */
export interface BlockPageResource {
    /**
     *
     * @type {number}
     * @memberof BlockPageResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof BlockPageResource
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof BlockPageResource
     */
    'category_id'?: string;
    /**
     *
     * @type {string}
     * @memberof BlockPageResource
     */
    'image'?: string;
    /**
     *
     * @type {object}
     * @memberof BlockPageResource
     */
    'structure'?: object;
    /**
     *
     * @type {number}
     * @memberof BlockPageResource
     */
    'order'?: number;
    /**
     *
     * @type {object}
     * @memberof BlockPageResource
     */
    'props'?: object;
}
/**
 * Block Resource model
 * @export
 * @interface BlockResource
 */
export interface BlockResource {
    /**
     *
     * @type {number}
     * @memberof BlockResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof BlockResource
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof BlockResource
     */
    'category_id'?: string;
    /**
     *
     * @type {string}
     * @memberof BlockResource
     */
    'image'?: string;
    /**
     *
     * @type {object}
     * @memberof BlockResource
     */
    'structure'?: object;
}
/**
 * Category model
 * @export
 * @interface Category
 */
export interface Category {
    /**
     *
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
}
/**
 * Category Resource model
 * @export
 * @interface CategoryResource
 */
export interface CategoryResource {
    /**
     *
     * @type {number}
     * @memberof CategoryResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof CategoryResource
     */
    'name'?: string;
}
/**
 * Constant model
 * @export
 * @interface Constant
 */
export interface Constant {
    /**
     *
     * @type {number}
     * @memberof Constant
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Constant
     */
    'site_name'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Constant
     */
    'text'?: Array<string>;
}
/**
 * Constant Resource model
 * @export
 * @interface ConstantResource
 */
export interface ConstantResource {
    /**
     *
     * @type {number}
     * @memberof ConstantResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof ConstantResource
     */
    'site_name'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ConstantResource
     */
    'pages'?: Array<string>;
}
/**
 * Draft model
 * @export
 * @interface Draft
 */
export interface Draft {
    /**
     *
     * @type {number}
     * @memberof Draft
     */
    'page_id'?: number;
    /**
     *
     * @type {Array<object>}
     * @memberof Draft
     */
    'page_draft'?: Array<object>;
}
/**
 * Dynamic Page Resource model
 * @export
 * @interface DynamicPageResource
 */
export interface DynamicPageResource {
    /**
     *
     * @type {number}
     * @memberof DynamicPageResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof DynamicPageResource
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof DynamicPageResource
     */
    'route'?: string;
    /**
     *
     * @type {string}
     * @memberof DynamicPageResource
     */
    'redirect'?: string;
    /**
     *
     * @type {number}
     * @memberof DynamicPageResource
     */
    'model_id'?: number;
    /**
     *
     * @type {string}
     * @memberof DynamicPageResource
     */
    'model_type'?: string;
    /**
     *
     * @type {number}
     * @memberof DynamicPageResource
     */
    'template_id'?: number;
}
/**
 * History model
 * @export
 * @interface History
 */
export interface History {
    /**
     *
     * @type {number}
     * @memberof History
     */
    'id'?: number;
    /**
     *
     * @type {number}
     * @memberof History
     */
    'model_id'?: number;
    /**
     *
     * @type {string}
     * @memberof History
     */
    'model_name'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof History
     */
    'widgets'?: Array<object>;
}
/**
 * HistoryRequest body data
 * @export
 * @interface HistoryRequest
 */
export interface HistoryRequest {
    /**
     *
     * @type {number}
     * @memberof HistoryRequest
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof HistoryRequest
     */
    'title'?: string;
}
/**
 * History Resource model
 * @export
 * @interface HistoryResource
 */
export interface HistoryResource {
    /**
     *
     * @type {number}
     * @memberof HistoryResource
     */
    'id'?: number;
    /**
     *
     * @type {number}
     * @memberof HistoryResource
     */
    'model_id'?: number;
    /**
     *
     * @type {string}
     * @memberof HistoryResource
     */
    'model_name'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof HistoryResource
     */
    'widgets'?: Array<object>;
    /**
     *
     * @type {string}
     * @memberof HistoryResource
     */
    'created_at'?: string;
    /**
     *
     * @type {string}
     * @memberof HistoryResource
     */
    'updated_at'?: string;

    'title'? : string
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Array<AdventureResource>}
     * @memberof InlineResponse200
     */
    'data'?: Array<AdventureResource>;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {AdventureResource}
     * @memberof InlineResponse2001
     */
    'data'?: AdventureResource;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     *
     * @type {Array<RegionResource>}
     * @memberof InlineResponse20010
     */
    'data'?: Array<RegionResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     *
     * @type {Array<RegionFullResource>}
     * @memberof InlineResponse20011
     */
    'data'?: Array<RegionFullResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     *
     * @type {Array<SiteResource>}
     * @memberof InlineResponse20012
     */
    'data'?: Array<SiteResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     *
     * @type {Array<RuleResource>}
     * @memberof InlineResponse20013
     */
    'data'?: Array<RuleResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     *
     * @type {PageResource}
     * @memberof InlineResponse20014
     */
    'data'?: PageResource;
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     *
     * @type {PageListResource}
     * @memberof InlineResponse20015
     */
    'data'?: PageListResource;
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     *
     * @type {Array<BlockPageResource>}
     * @memberof InlineResponse20016
     */
    'data'?: Array<BlockPageResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     *
     * @type {Array<TemplateResource>}
     * @memberof InlineResponse20017
     */
    'data'?: Array<TemplateResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     *
     * @type {TemplateResource}
     * @memberof InlineResponse20018
     */
    'data'?: TemplateResource;
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     *
     * @type {Array<ProductResource>}
     * @memberof InlineResponse20019
     */
    'data'?: Array<ProductResource>;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {Array<AssetResource>}
     * @memberof InlineResponse2002
     */
    'data'?: Array<AssetResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     *
     * @type {ProductResource}
     * @memberof InlineResponse20020
     */
    'data'?: ProductResource;
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     *
     * @type {Array<MenuResource>}
     * @memberof InlineResponse20021
     */
    'data'?: Array<MenuResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     *
     * @type {Array<RedirectResource>}
     * @memberof InlineResponse20022
     */
    'data'?: Array<RedirectResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     *
     * @type {Array<SettingResource>}
     * @memberof InlineResponse20023
     */
    'data'?: Array<SettingResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     *
     * @type {PostResource}
     * @memberof InlineResponse20024
     */
    'data'?: PostResource;
}
/**
 *
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     *
     * @type {HistoryResource}
     * @memberof InlineResponse20025
     */
    'data'?: HistoryResource;
}
/**
 *
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     *
     * @type {Array<MediaTypeResource>}
     * @memberof InlineResponse20026
     */
    'data'?: Array<MediaTypeResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     *
     * @type {MediaTypeResource}
     * @memberof InlineResponse20027
     */
    'data'?: MediaTypeResource;
}
/**
 *
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     *
     * @type {MenuResource}
     * @memberof InlineResponse20028
     */
    'data'?: MenuResource;
}
/**
 *
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     *
     * @type {Array<NotificationResource>}
     * @memberof InlineResponse20029
     */
    'data'?: Array<NotificationResource>;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     *
     * @type {AssetResource}
     * @memberof InlineResponse2003
     */
    'data'?: AssetResource;
}
/**
 *
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     *
     * @type {NotificationResource}
     * @memberof InlineResponse20030
     */
    'data'?: NotificationResource;
}
/**
 *
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     *
     * @type {Array<PageResource>}
     * @memberof InlineResponse20031
     */
    'data'?: Array<PageResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     *
     * @type {PageDraftResource}
     * @memberof InlineResponse20032
     */
    'data'?: PageDraftResource;
}
/**
 *
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     *
     * @type {DynamicPageResource}
     * @memberof InlineResponse20033
     */
    'data'?: DynamicPageResource;
}
/**
 *
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     *
     * @type {Array<PostResource>}
     * @memberof InlineResponse20034
     */
    'data'?: Array<PostResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     *
     * @type {RedirectResource}
     * @memberof InlineResponse20035
     */
    'data'?: RedirectResource;
}
/**
 *
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     *
     * @type {RegionResource}
     * @memberof InlineResponse20036
     */
    'data'?: RegionResource;
}
/**
 *
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     *
     * @type {Rule}
     * @memberof InlineResponse20037
     */
    'data'?: Rule;
}
/**
 *
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     *
     * @type {Array<SectionResource>}
     * @memberof InlineResponse20038
     */
    'data'?: Array<SectionResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     *
     * @type {SectionResource}
     * @memberof InlineResponse20039
     */
    'data'?: SectionResource;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     *
     * @type {Array<BlockResource>}
     * @memberof InlineResponse2004
     */
    'data'?: Array<BlockResource>;
}
/**
 *
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     *
     * @type {SettingResource}
     * @memberof InlineResponse20040
     */
    'data'?: SettingResource;
}
/**
 *
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     *
     * @type {SiteResource}
     * @memberof InlineResponse20041
     */
    'data'?: SiteResource;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     *
     * @type {BlockResource}
     * @memberof InlineResponse2005
     */
    'data'?: BlockResource;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     *
     * @type {Array<CategoryResource>}
     * @memberof InlineResponse2006
     */
    'data'?: Array<CategoryResource>;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     *
     * @type {CategoryResource}
     * @memberof InlineResponse2007
     */
    'data'?: CategoryResource;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     *
     * @type {Array<ConstantResource>}
     * @memberof InlineResponse2008
     */
    'data'?: Array<ConstantResource>;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     *
     * @type {ConstantResource}
     * @memberof InlineResponse2009
     */
    'data'?: ConstantResource;
}
/**
 * Inquiry Resource model
 * @export
 * @interface InquiryResource
 */
export interface InquiryResource {
    /**
     *
     * @type {string}
     * @memberof InquiryResource
     */
    'user_name'?: string;
    /**
     *
     * @type {string}
     * @memberof InquiryResource
     */
    'role'?: string;
    /**
     *
     * @type {string}
     * @memberof InquiryResource
     */
    'level'?: string;
    /**
     *
     * @type {string}
     * @memberof InquiryResource
     */
    'application'?: string;
    /**
     *
     * @type {Array<InquiryResourceBrands>}
     * @memberof InquiryResource
     */
    'brands'?: Array<InquiryResourceBrands>;
}
/**
 *
 * @export
 * @interface InquiryResourceBrand
 */
export interface InquiryResourceBrand {
    /**
     *
     * @type {string}
     * @memberof InquiryResourceBrand
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof InquiryResourceBrand
     */
    'logo'?: string;
}
/**
 *
 * @export
 * @interface InquiryResourceBrands
 */
export interface InquiryResourceBrands {
    /**
     *
     * @type {InquiryResourceBrand}
     * @memberof InquiryResourceBrands
     */
    'brand'?: InquiryResourceBrand;
}
/**
 * Login model
 * @export
 * @interface Login
 */
export interface Login {
    /**
     *
     * @type {string}
     * @memberof Login
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof Login
     */
    'password'?: string;
}
/**
 * Login Resource model
 * @export
 * @interface LoginResource
 */
export interface LoginResource {
    /**
     *
     * @type {number}
     * @memberof LoginResource
     */
    'user_id'?: number;
    /**
     *
     * @type {string}
     * @memberof LoginResource
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof LoginResource
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof LoginResource
     */
    'level'?: string;
    /**
     *
     * @type {string}
     * @memberof LoginResource
     */
    'access_token'?: string;
    /**
     *
     * @type {string}
     * @memberof LoginResource
     */
    'token_type'?: string;
    /**
     *
     * @type {string}
     * @memberof LoginResource
     */
    'expires_at'?: string;
}
/**
 * Media model
 * @export
 * @interface Media
 */
export interface Media {
    /**
     *
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Media
     */
    'filename'?: string;
    /**
     *
     * @type {number}
     * @memberof Media
     */
    'media_type_id'?: number;
}
/**
 * MediaType model
 * @export
 * @interface MediaType
 */
export interface MediaType {
    /**
     *
     * @type {number}
     * @memberof MediaType
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof MediaType
     */
    'name'?: string;
}
/**
 * MediaType Resource model
 * @export
 * @interface MediaTypeResource
 */
export interface MediaTypeResource {
    /**
     *
     * @type {number}
     * @memberof MediaTypeResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof MediaTypeResource
     */
    'name'?: string;
}
/**
 * Menu model
 * @export
 * @interface Menu
 */
export interface Menu {
    /**
     *
     * @type {number}
     * @memberof Menu
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Menu
     */
    'title'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof Menu
     */
    'widgets'?: Array<object>;
}
/**
 * Menu Resource model
 * @export
 * @interface MenuResource
 */
export interface MenuResource {
    /**
     *
     * @type {number}
     * @memberof MenuResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof MenuResource
     */
    'title'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof MenuResource
     */
    'widgets'?: Array<object>;
}
/**
 * Notification model
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     *
     * @type {number}
     * @memberof Notification
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    'text'?: string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    'link'?: string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    'text_color'?: string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    'background_color'?: string;
    /**
     *
     * @type {Array<number>}
     * @memberof Notification
     */
    'page_Ids'?: Array<number>;
}
/**
 * Notification Page model
 * @export
 * @interface NotificationPage
 */
export interface NotificationPage {
    /**
     *
     * @type {number}
     * @memberof NotificationPage
     */
    'notification_id'?: number;
    /**
     *
     * @type {number}
     * @memberof NotificationPage
     */
    'page_id'?: number;
}
/**
 * Notification Resource model
 * @export
 * @interface NotificationResource
 */
export interface NotificationResource {
    /**
     *
     * @type {number}
     * @memberof NotificationResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof NotificationResource
     */
    'text'?: string;
    /**
     *
     * @type {string}
     * @memberof NotificationResource
     */
    'link'?: string;
    /**
     *
     * @type {string}
     * @memberof NotificationResource
     */
    'text_color'?: string;
    /**
     *
     * @type {string}
     * @memberof NotificationResource
     */
    'background_color'?: string;
    /**
     *
     * @type {Array<number>}
     * @memberof NotificationResource
     */
    'page_Ids'?: Array<number>;
    /**
     *
     * @type {Array<NotificationResourcePages>}
     * @memberof NotificationResource
     */
    'pages'?: Array<NotificationResourcePages>;
}
/**
 *
 * @export
 * @interface NotificationResourcePages
 */
export interface NotificationResourcePages {
    /**
     *
     * @type {string}
     * @memberof NotificationResourcePages
     */
    'id'?: string;
    /**
     *
     * @type {number}
     * @memberof NotificationResourcePages
     */
    'title'?: number;
}
/**
 * Page model
 * @export
 * @interface Page
 */
export interface Page {
    /**
     *
     * @type {number}
     * @memberof Page
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Page
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof Page
     */
    'route'?: string;
    /**
     *
     * @type {string}
     * @memberof Page
     */
    'redirect'?: string;
    /**
     *
     * @type {string}
     * @memberof Page
     */
    'fetchUrl'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof Page
     */
    'meta'?: Array<object>;
    /**
     *
     * @type {Array<number>}
     * @memberof Page
     */
    'block_ids'?: Array<number>;
    /**
     *
     * @type {Array<object>}
     * @memberof Page
     */
    'draft'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof Page
     */
    'widgets'?: Array<object>;
    /**
     *
     * @type {number}
     * @memberof Page
     */
    'model_id'?: number;
    /**
     *
     * @type {string}
     * @memberof Page
     */
    'model_type'?: string;
    /**
     *
     * @type {number}
     * @memberof Page
     */
    'template_id'?: number;
}
/**
 * Page Draft Resource model
 * @export
 * @interface PageDraftResource
 */
export interface PageDraftResource {
    /**
     *
     * @type {number}
     * @memberof PageDraftResource
     */
    'page_id'?: number;
    /**
     *
     * @type {object}
     * @memberof PageDraftResource
     */
    'page_draft'?: object;
}
/**
 * Page Full Resource model
 * @export
 * @interface PageFullResource
 */
export interface PageFullResource {
    /**
     *
     * @type {number}
     * @memberof PageFullResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageFullResource
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof PageFullResource
     */
    'route'?: string;
    /**
     *
     * @type {string}
     * @memberof PageFullResource
     */
    'fetchUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof PageFullResource
     */
    'meta'?: string;
    /**
     *
     * @type {Array<PageFullResourceBlocks>}
     * @memberof PageFullResource
     */
    'blocks'?: Array<PageFullResourceBlocks>;
}
/**
 *
 * @export
 * @interface PageFullResourceBlocks
 */
export interface PageFullResourceBlocks {
    /**
     *
     * @type {number}
     * @memberof PageFullResourceBlocks
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageFullResourceBlocks
     */
    'name'?: string;
    /**
     *
     * @type {number}
     * @memberof PageFullResourceBlocks
     */
    'category_id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageFullResourceBlocks
     */
    'image'?: string;
    /**
     *
     * @type {object}
     * @memberof PageFullResourceBlocks
     */
    'structure'?: object;
    /**
     *
     * @type {object}
     * @memberof PageFullResourceBlocks
     */
    'props'?: object;
}
/**
 * Page List Resource model
 * @export
 * @interface PageListResource
 */
export interface PageListResource {
    /**
     *
     * @type {number}
     * @memberof PageListResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageListResource
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof PageListResource
     */
    'route'?: string;
    /**
     *
     * @type {string}
     * @memberof PageListResource
     */
    'redirect'?: string;
    /**
     *
     * @type {string}
     * @memberof PageListResource
     */
    'fetchUrl'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof PageListResource
     */
    'meta'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof PageListResource
     */
    'widgets'?: Array<object>;
    /**
     *
     * @type {number}
     * @memberof PageListResource
     */
    'model_id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageListResource
     */
    'model_type'?: string;
    /**
     *
     * @type {number}
     * @memberof PageListResource
     */
    'template_id'?: number;
}
/**
 * Page Resource model
 * @export
 * @interface PageResource
 */
export interface PageResource {
    /**
     *
     * @type {number}
     * @memberof PageResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageResource
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof PageResource
     */
    'route'?: string;
    /**
     *
     * @type {string}
     * @memberof PageResource
     */
    'redirect'?: string;
    /**
     *
     * @type {string}
     * @memberof PageResource
     */
    'fetchUrl'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof PageResource
     */
    'meta'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof PageResource
     */
    'draft'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof PageResource
     */
    'widgets'?: Array<object>;
    /**
     *
     * @type {number}
     * @memberof PageResource
     */
    'model_id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageResource
     */
    'model_type'?: string;
    /**
     *
     * @type {number}
     * @memberof PageResource
     */
    'template_id'?: number;
    /**
     *
     * @type {Array<PageResourceNotifications>}
     * @memberof PageResource
     */
    'notifications'?: Array<PageResourceNotifications>;
}
/**
 *
 * @export
 * @interface PageResourceNotifications
 */
export interface PageResourceNotifications {
    /**
     *
     * @type {number}
     * @memberof PageResourceNotifications
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PageResourceNotifications
     */
    'text'?: string;
    /**
     *
     * @type {string}
     * @memberof PageResourceNotifications
     */
    'text_color'?: string;
    /**
     *
     * @type {string}
     * @memberof PageResourceNotifications
     */
    'background_color'?: string;
}
/**
 * Post model
 * @export
 * @interface Post
 */
export interface Post {
    /**
     *
     * @type {number}
     * @memberof Post
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Post
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof Post
     */
    'route'?: string;
    /**
     *
     * @type {number}
     * @memberof Post
     */
    'category_id'?: number;
    /**
     *
     * @type {Array<object>}
     * @memberof Post
     */
    'widgets'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof Post
     */
    'meta'?: Array<object>;
    /**
     *
     * @type {Array<string>}
     * @memberof Post
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof Post
     */
    'status'?: number;
}
/**
 * Post Resource model
 * @export
 * @interface PostResource
 */
export interface PostResource {
    /**
     *
     * @type {number}
     * @memberof PostResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof PostResource
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof PostResource
     */
    'route'?: string;
    /**
     *
     * @type {number}
     * @memberof PostResource
     */
    'category_id'?: number;
    /**
     *
     * @type {Array<object>}
     * @memberof PostResource
     */
    'widgets'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof PostResource
     */
    'meta'?: Array<object>;
    /**
     *
     * @type {Array<string>}
     * @memberof PostResource
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof PostResource
     */
    'status'?: number;
}
/**
 * Product model
 * @export
 * @interface Product
 */
export interface Product {
    /**
     *
     * @type {number}
     * @memberof Product
     */
    'id'?: number;
    /**
     *
     * @type {number}
     * @memberof Product
     */
    'product_id'?: number;
    /**
     *
     * @type {Array<object>}
     * @memberof Product
     */
    'product_meta'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof Product
     */
    'product_content'?: Array<object>;
}
/**
 * Product Resource model
 * @export
 * @interface ProductResource
 */
export interface ProductResource {
    /**
     *
     * @type {number}
     * @memberof ProductResource
     */
    'id'?: number;
    /**
     *
     * @type {number}
     * @memberof ProductResource
     */
    'product_id'?: number;
    /**
     *
     * @type {Array<object>}
     * @memberof ProductResource
     */
    'product_meta'?: Array<object>;
    /**
     *
     * @type {Array<object>}
     * @memberof ProductResource
     */
    'product_content'?: Array<object>;
}
/**
 * Redirect model
 * @export
 * @interface Redirect
 */
export interface Redirect {
    /**
     *
     * @type {number}
     * @memberof Redirect
     */
    'id'?: number;
    /**
     *
     * @type {number}
     * @memberof Redirect
     */
    'page_id'?: number;
    /**
     *
     * @type {string}
     * @memberof Redirect
     */
    'source_url'?: string;
    /**
     *
     * @type {string}
     * @memberof Redirect
     */
    'redirect_type'?: string;
    /**
     *
     * @type {string}
     * @memberof Redirect
     */
    'redirect_url'?: string;
    /**
     *
     * @type {number}
     * @memberof Redirect
     */
    'redirect_code'?: number;
    /**
     *
     * @type {string}
     * @memberof Redirect
     */
    'regex'?: string;
}
/**
 * Redirect Resource model
 * @export
 * @interface RedirectResource
 */
export interface RedirectResource {
    /**
     *
     * @type {number}
     * @memberof RedirectResource
     */
    'id'?: number;
    /**
     *
     * @type {number}
     * @memberof RedirectResource
     */
    'page_id'?: number;
    /**
     *
     * @type {string}
     * @memberof RedirectResource
     */
    'source_url'?: string;
    /**
     *
     * @type {string}
     * @memberof RedirectResource
     */
    'page_route'?: string;
    /**
     *
     * @type {string}
     * @memberof RedirectResource
     */
    'redirect_type'?: string;
    /**
     *
     * @type {string}
     * @memberof RedirectResource
     */
    'redirect_url'?: string;
    /**
     *
     * @type {number}
     * @memberof RedirectResource
     */
    'redirect_code'?: number;
    /**
     *
     * @type {string}
     * @memberof RedirectResource
     */
    'regex'?: string;
}
/**
 * Region model
 * @export
 * @interface Region
 */
export interface Region {
    /**
     *
     * @type {number}
     * @memberof Region
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof Region
     */
    'image'?: string;
    /**
     *
     * @type {number}
     * @memberof Region
     */
    'site_id'?: number;
    /**
     *
     * @type {number}
     * @memberof Region
     */
    'order'?: number;
}
/**
 * Region Full Resource model
 * @export
 * @interface RegionFullResource
 */
export interface RegionFullResource {
    /**
     *
     * @type {number}
     * @memberof RegionFullResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof RegionFullResource
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof RegionFullResource
     */
    'image'?: string;
    /**
     *
     * @type {number}
     * @memberof RegionFullResource
     */
    'site_id'?: number;
    /**
     *
     * @type {number}
     * @memberof RegionFullResource
     */
    'order'?: number;
    /**
     *
     * @type {Array<RegionFullResourceAdventures>}
     * @memberof RegionFullResource
     */
    'adventures'?: Array<RegionFullResourceAdventures>;
}
/**
 *
 * @export
 * @interface RegionFullResourceAdventures
 */
export interface RegionFullResourceAdventures {
    /**
     *
     * @type {string}
     * @memberof RegionFullResourceAdventures
     */
    'country_name'?: string;
    /**
     *
     * @type {string}
     * @memberof RegionFullResourceAdventures
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RegionFullResourceAdventures
     */
    'highlights'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof RegionFullResourceAdventures
     */
    'testimonial'?: string;
    /**
     *
     * @type {string}
     * @memberof RegionFullResourceAdventures
     */
    'client_name'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RegionFullResourceAdventures
     */
    'slides'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof RegionFullResourceAdventures
     */
    'map_url'?: string;
}
/**
 * Region Resource model
 * @export
 * @interface RegionResource
 */
export interface RegionResource {
    /**
     *
     * @type {number}
     * @memberof RegionResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof RegionResource
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof RegionResource
     */
    'image'?: string;
    /**
     *
     * @type {number}
     * @memberof RegionResource
     */
    'site_id'?: number;
    /**
     *
     * @type {number}
     * @memberof RegionResource
     */
    'order'?: number;
}
/**
 * Rule model
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     *
     * @type {number}
     * @memberof Rule
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    'text'?: string;
    /**
     *
     * @type {number}
     * @memberof Rule
     */
    'site_id'?: number;
}
/**
 * Rule Resource model
 * @export
 * @interface RuleResource
 */
export interface RuleResource {
    /**
     *
     * @type {number}
     * @memberof RuleResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof RuleResource
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof RuleResource
     */
    'text'?: string;
    /**
     *
     * @type {AdventureResourceRegion}
     * @memberof RuleResource
     */
    'site'?: AdventureResourceRegion;
}
/**
 * Section model
 * @export
 * @interface Section
 */
export interface Section {
    /**
     *
     * @type {number}
     * @memberof Section
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Section
     */
    'name'?: string;
}
/**
 * Section Resource model
 * @export
 * @interface SectionResource
 */
export interface SectionResource {
    /**
     *
     * @type {number}
     * @memberof SectionResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof SectionResource
     */
    'name'?: string;
}
/**
 * Setting model
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     *
     * @type {number}
     * @memberof Setting
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    'key'?: string;
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    'value'?: string;
}
/**
 * Setting Resource model
 * @export
 * @interface SettingResource
 */
export interface SettingResource {
    /**
     *
     * @type {number}
     * @memberof SettingResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof SettingResource
     */
    'title'?: string;
    /**
     *
     * @type {string}
     * @memberof SettingResource
     */
    'key'?: string;
    /**
     *
     * @type {string}
     * @memberof SettingResource
     */
    'value'?: string;
}
/**
 * Site model
 * @export
 * @interface Site
 */
export interface Site {
    /**
     *
     * @type {number}
     * @memberof Site
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Site
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof Site
     */
    'flag_url'?: string;
    /**
     *
     * @type {number}
     * @memberof Site
     */
    'enable'?: number;
}
/**
 * Site Resource model
 * @export
 * @interface SiteResource
 */
export interface SiteResource {
    /**
     *
     * @type {number}
     * @memberof SiteResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof SiteResource
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof SiteResource
     */
    'flag_url'?: string;
    /**
     *
     * @type {number}
     * @memberof SiteResource
     */
    'enable'?: number;
}
/**
 * Slide model
 * @export
 * @interface Slide
 */
export interface Slide {
    /**
     *
     * @type {number}
     * @memberof Slide
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Slide
     */
    'url'?: string;
    /**
     *
     * @type {number}
     * @memberof Slide
     */
    'media_type_id'?: number;
}
/**
 * Subject model
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     *
     * @type {number}
     * @memberof Subject
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Subject
     */
    'name'?: string;
}
/**
 * Template model
 * @export
 * @interface Template
 */
export interface Template {
    /**
     *
     * @type {number}
     * @memberof Template
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Template
     */
    'name'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof Template
     */
    'widgets'?: Array<object>;
}
/**
 * Template Resource model
 * @export
 * @interface TemplateResource
 */
export interface TemplateResource {
    /**
     *
     * @type {number}
     * @memberof TemplateResource
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof TemplateResource
     */
    'name'?: string;
    /**
     *
     * @type {Array<object>}
     * @memberof TemplateResource
     */
    'widgets'?: Array<object>;
}
/**
 * User model
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'level'?: string;
}
/**
 * Widgets model
 * @export
 * @interface Widgets
 */
export interface Widgets {
    /**
     *
     * @type {number}
     * @memberof Widgets
     */
    'page_id'?: number;
    /**
     *
     * @type {Array<object>}
     * @memberof Widgets
     */
    'widgets'?: Array<object>;
}

/**
 * AdventureApi - axios parameter creator
 * @export
 */
export const AdventureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Adventure} adventure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdventure: async (adventure: Adventure, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adventure' is not null or undefined
            assertParamExists('addAdventure', 'adventure', adventure)
            const localVarPath = `/adventure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adventure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adventureList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/adventure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventure: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAdventure', 'id', id)
            const localVarPath = `/adventure/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventure: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAdventure', 'id', id)
            const localVarPath = `/adventure/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} regionId Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureByRegionId: async (regionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getAdventureByRegionId', 'regionId', regionId)
            const localVarPath = `/adventure/getByRegionId/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {Adventure} adventure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventure: async (id: number, adventure: Adventure, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAdventure', 'id', id)
            // verify required parameter 'adventure' is not null or undefined
            assertParamExists('updateAdventure', 'adventure', adventure)
            const localVarPath = `/adventure/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adventure, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdventureApi - functional programming interface
 * @export
 */
export const AdventureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdventureApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Adventure} adventure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAdventure(adventure: Adventure, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Adventure>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAdventure(adventure, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adventureList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adventureList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdventure(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAdventure(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventure(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdventure(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} regionId Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureByRegionId(regionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdventureByRegionId(regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {Adventure} adventure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdventure(id: number, adventure: Adventure, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Adventure>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdventure(id, adventure, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdventureApi - factory interface
 * @export
 */
export const AdventureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdventureApiFp(configuration)
    return {
        /**
         *
         * @param {Adventure} adventure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdventure(adventure: Adventure, options?: any): AxiosPromise<Adventure> {
            return localVarFp.addAdventure(adventure, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adventureList(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.adventureList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdventure(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteAdventure(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventure(id: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getAdventure(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} regionId Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureByRegionId(regionId: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getAdventureByRegionId(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Adventure ID
         * @param {Adventure} adventure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdventure(id: number, adventure: Adventure, options?: any): AxiosPromise<Adventure> {
            return localVarFp.updateAdventure(id, adventure, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdventureApi - object-oriented interface
 * @export
 * @class AdventureApi
 * @extends {BaseAPI}
 */
export class AdventureApi extends BaseAPI {
    /**
     *
     * @param {Adventure} adventure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureApi
     */
    public addAdventure(adventure: Adventure, options?: AxiosRequestConfig) {
        return AdventureApiFp(this.configuration).addAdventure(adventure, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureApi
     */
    public adventureList(options?: AxiosRequestConfig) {
        return AdventureApiFp(this.configuration).adventureList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Adventure ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureApi
     */
    public deleteAdventure(id: number, options?: AxiosRequestConfig) {
        return AdventureApiFp(this.configuration).deleteAdventure(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Adventure ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureApi
     */
    public getAdventure(id: number, options?: AxiosRequestConfig) {
        return AdventureApiFp(this.configuration).getAdventure(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} regionId Region ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureApi
     */
    public getAdventureByRegionId(regionId: number, options?: AxiosRequestConfig) {
        return AdventureApiFp(this.configuration).getAdventureByRegionId(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Adventure ID
     * @param {Adventure} adventure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdventureApi
     */
    public updateAdventure(id: number, adventure: Adventure, options?: AxiosRequestConfig) {
        return AdventureApiFp(this.configuration).updateAdventure(id, adventure, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Asset} asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset: async (asset: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('addAsset', 'asset', asset)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAsset', 'id', id)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchAsset: async (string: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'string' is not null or undefined
            assertParamExists('doSearchAsset', 'string', string)
            const localVarPath = `/asset/searchAsset/{string}`
                .replace(`{${"string"}}`, encodeURIComponent(String(string)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAsset', 'id', id)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {Asset} asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (id: number, asset: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAsset', 'id', id)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('updateAsset', 'asset', asset)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Asset} asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAsset(asset: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAsset(asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsset(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doSearchAsset(string: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doSearchAsset(string, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {Asset} asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(id: number, asset: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(id, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         *
         * @param {Asset} asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset(asset: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.addAsset(asset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetList(options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.assetList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteAsset(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchAsset(string: string, options?: any): AxiosPromise<void> {
            return localVarFp.doSearchAsset(string, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(id: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getAsset(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Asset ID
         * @param {Asset} asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(id: number, asset: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.updateAsset(id, asset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     *
     * @param {Asset} asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public addAsset(asset: Asset, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).addAsset(asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetList(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).assetList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Asset ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAsset(id: number, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).deleteAsset(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} string string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public doSearchAsset(string: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).doSearchAsset(string, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Asset ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAsset(id: number, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAsset(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Asset ID
     * @param {Asset} asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(id: number, asset: Asset, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAsset(id, asset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/getUserInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} publicKey public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInquiry: async (publicKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKey' is not null or undefined
            assertParamExists('userInquiry', 'publicKey', publicKey)
            const localVarPath = `/auth/inquiry/{publicKey}`
                .replace(`{${"publicKey"}}`, encodeURIComponent(String(publicKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} publicKey public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInquiry(publicKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InquiryResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInquiry(publicKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<any> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} publicKey public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInquiry(publicKey: string, options?: any): AxiosPromise<InquiryResource> {
            return localVarFp.userInquiry(publicKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserInfo(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} publicKey public Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public userInquiry(publicKey: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).userInquiry(publicKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockApi - axios parameter creator
 * @export
 */
export const BlockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Block} block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBlock: async (block: Block, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'block' is not null or undefined
            assertParamExists('addBlock', 'block', block)
            const localVarPath = `/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(block, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlock: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBlock', 'id', id)
            const localVarPath = `/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlock', 'id', id)
            const localVarPath = `/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Block ID
         * @param {Block} block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlock: async (id: number, block: Block, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBlock', 'id', id)
            // verify required parameter 'block' is not null or undefined
            assertParamExists('updateBlock', 'block', block)
            const localVarPath = `/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(block, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BlockPage} blockPage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProps: async (blockPage: BlockPage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockPage' is not null or undefined
            assertParamExists('updateProps', 'blockPage', blockPage)
            const localVarPath = `/block/updateProps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockPage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockApi - functional programming interface
 * @export
 */
export const BlockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Block} block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBlock(block: Block, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBlock(block, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlock(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlock(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlock(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Block ID
         * @param {Block} block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlock(id: number, block: Block, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBlock(id, block, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {BlockPage} blockPage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProps(blockPage: BlockPage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProps(blockPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockApi - factory interface
 * @export
 */
export const BlockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockApiFp(configuration)
    return {
        /**
         *
         * @param {Block} block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBlock(block: Block, options?: any): AxiosPromise<Block> {
            return localVarFp.addBlock(block, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockList(options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.blockList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlock(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteBlock(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(id: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.getBlock(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Block ID
         * @param {Block} block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlock(id: number, block: Block, options?: any): AxiosPromise<Block> {
            return localVarFp.updateBlock(id, block, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {BlockPage} blockPage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProps(blockPage: BlockPage, options?: any): AxiosPromise<any> {
            return localVarFp.updateProps(blockPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockApi - object-oriented interface
 * @export
 * @class BlockApi
 * @extends {BaseAPI}
 */
export class BlockApi extends BaseAPI {
    /**
     *
     * @param {Block} block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public addBlock(block: Block, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).addBlock(block, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public blockList(options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).blockList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public deleteBlock(id: number, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).deleteBlock(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public getBlock(id: number, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).getBlock(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Block ID
     * @param {Block} block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public updateBlock(id: number, block: Block, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).updateBlock(id, block, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {BlockPage} blockPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public updateProps(blockPage: BlockPage, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).updateProps(blockPage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _062b0e17b0b265231ad33ece1785b1fe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _0fd985657bea3b2f3a919bdc16fec5b9: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_0fd985657bea3b2f3a919bdc16fec5b9', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Category ID
         * @param {Category} category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _2aeef67a0c5f4a9161985387cab71ccc: async (id: number, category: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_2aeef67a0c5f4a9161985387cab71ccc', 'id', id)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('_2aeef67a0c5f4a9161985387cab71ccc', 'category', category)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Category} category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _8a437c9b58cb5726b37615e8a5a9857c: async (category: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('_8a437c9b58cb5726b37615e8a5a9857c', 'category', category)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        c22ffb01fe96cd5baf6a4174466b2672: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('c22ffb01fe96cd5baf6a4174466b2672', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _062b0e17b0b265231ad33ece1785b1fe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._062b0e17b0b265231ad33ece1785b1fe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _0fd985657bea3b2f3a919bdc16fec5b9(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._0fd985657bea3b2f3a919bdc16fec5b9(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Category ID
         * @param {Category} category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _2aeef67a0c5f4a9161985387cab71ccc(id: number, category: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._2aeef67a0c5f4a9161985387cab71ccc(id, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {Category} category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _8a437c9b58cb5726b37615e8a5a9857c(category: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._8a437c9b58cb5726b37615e8a5a9857c(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async c22ffb01fe96cd5baf6a4174466b2672(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.c22ffb01fe96cd5baf6a4174466b2672(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _062b0e17b0b265231ad33ece1785b1fe(options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp._062b0e17b0b265231ad33ece1785b1fe(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _0fd985657bea3b2f3a919bdc16fec5b9(id: number, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp._0fd985657bea3b2f3a919bdc16fec5b9(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Category ID
         * @param {Category} category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _2aeef67a0c5f4a9161985387cab71ccc(id: number, category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp._2aeef67a0c5f4a9161985387cab71ccc(id, category, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Category} category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _8a437c9b58cb5726b37615e8a5a9857c(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp._8a437c9b58cb5726b37615e8a5a9857c(category, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        c22ffb01fe96cd5baf6a4174466b2672(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.c22ffb01fe96cd5baf6a4174466b2672(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _062b0e17b0b265231ad33ece1785b1fe(options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._062b0e17b0b265231ad33ece1785b1fe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _0fd985657bea3b2f3a919bdc16fec5b9(id: number, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._0fd985657bea3b2f3a919bdc16fec5b9(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Category ID
     * @param {Category} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _2aeef67a0c5f4a9161985387cab71ccc(id: number, category: Category, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._2aeef67a0c5f4a9161985387cab71ccc(id, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Category} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _8a437c9b58cb5726b37615e8a5a9857c(category: Category, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._8a437c9b58cb5726b37615e8a5a9857c(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public c22ffb01fe96cd5baf6a4174466b2672(id: number, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).c22ffb01fe96cd5baf6a4174466b2672(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConstantApi - axios parameter creator
 * @export
 */
export const ConstantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Constant} constant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addConstant: async (constant: Constant, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'constant' is not null or undefined
            assertParamExists('addConstant', 'constant', constant)
            const localVarPath = `/constant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(constant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constantList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/constant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConstant: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConstant', 'id', id)
            const localVarPath = `/constant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstant: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConstant', 'id', id)
            const localVarPath = `/constant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} siteName Site Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstants: async (siteName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteName' is not null or undefined
            assertParamExists('getConstants', 'siteName', siteName)
            const localVarPath = `/constant/getConstants/{siteName}`
                .replace(`{${"siteName"}}`, encodeURIComponent(String(siteName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {Constant} constant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConstant: async (id: number, constant: Constant, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateConstant', 'id', id)
            // verify required parameter 'constant' is not null or undefined
            assertParamExists('updateConstant', 'constant', constant)
            const localVarPath = `/constant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(constant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConstantApi - functional programming interface
 * @export
 */
export const ConstantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConstantApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Constant} constant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addConstant(constant: Constant, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Constant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addConstant(constant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constantList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.constantList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConstant(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConstant(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstant(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstant(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} siteName Site Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstants(siteName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstants(siteName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {Constant} constant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConstant(id: number, constant: Constant, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Constant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConstant(id, constant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConstantApi - factory interface
 * @export
 */
export const ConstantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConstantApiFp(configuration)
    return {
        /**
         *
         * @param {Constant} constant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addConstant(constant: Constant, options?: any): AxiosPromise<Constant> {
            return localVarFp.addConstant(constant, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constantList(options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.constantList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConstant(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteConstant(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstant(id: number, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.getConstant(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} siteName Site Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstants(siteName: string, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.getConstants(siteName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Constant ID
         * @param {Constant} constant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConstant(id: number, constant: Constant, options?: any): AxiosPromise<Constant> {
            return localVarFp.updateConstant(id, constant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConstantApi - object-oriented interface
 * @export
 * @class ConstantApi
 * @extends {BaseAPI}
 */
export class ConstantApi extends BaseAPI {
    /**
     *
     * @param {Constant} constant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstantApi
     */
    public addConstant(constant: Constant, options?: AxiosRequestConfig) {
        return ConstantApiFp(this.configuration).addConstant(constant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstantApi
     */
    public constantList(options?: AxiosRequestConfig) {
        return ConstantApiFp(this.configuration).constantList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Constant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstantApi
     */
    public deleteConstant(id: number, options?: AxiosRequestConfig) {
        return ConstantApiFp(this.configuration).deleteConstant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Constant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstantApi
     */
    public getConstant(id: number, options?: AxiosRequestConfig) {
        return ConstantApiFp(this.configuration).getConstant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} siteName Site Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstantApi
     */
    public getConstants(siteName: string, options?: AxiosRequestConfig) {
        return ConstantApiFp(this.configuration).getConstants(siteName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Constant ID
     * @param {Constant} constant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstantApi
     */
    public updateConstant(id: number, constant: Constant, options?: AxiosRequestConfig) {
        return ConstantApiFp(this.configuration).updateConstant(id, constant, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExodusAPIsApi - axios parameter creator
 * @export
 */
export const ExodusAPIsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} adventureId Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureInfo: async (adventureId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adventureId' is not null or undefined
            assertParamExists('getAdventureInfo', 'adventureId', adventureId)
            const localVarPath = `/exodus/getAdventureInfo/{adventureId}`
                .replace(`{${"adventureId"}}`, encodeURIComponent(String(adventureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} regionId Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureList: async (regionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getAdventureList', 'regionId', regionId)
            const localVarPath = `/exodus/getAdventureList/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} siteName Site Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstantsBySiteName: async (siteName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteName' is not null or undefined
            assertParamExists('getConstantsBySiteName', 'siteName', siteName)
            const localVarPath = `/exodus/getBySiteName/{siteName}`
                .replace(`{${"siteName"}}`, encodeURIComponent(String(siteName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exodus/getRegionList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exodus/getRegions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionsBysiteId: async (siteId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('getRegionsBysiteId', 'siteId', siteId)
            const localVarPath = `/exodus/getRegionsBySiteId/{siteId}`
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesBySiteId: async (siteId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('getRulesBySiteId', 'siteId', siteId)
            const localVarPath = `/exodus/getRulesBySiteId/{siteId}`
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exodus/getSites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExodusAPIsApi - functional programming interface
 * @export
 */
export const ExodusAPIsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExodusAPIsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} adventureId Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureInfo(adventureId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdventureInfo(adventureId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} regionId Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdventureList(regionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdventureList(regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} siteName Site Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConstantsBySiteName(siteName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConstantsBySiteName(siteName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegionList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegionsBysiteId(siteId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionsBysiteId(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRulesBySiteId(siteId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRulesBySiteId(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiteList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiteList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExodusAPIsApi - factory interface
 * @export
 */
export const ExodusAPIsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExodusAPIsApiFp(configuration)
    return {
        /**
         *
         * @param {number} adventureId Adventure ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureInfo(adventureId: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getAdventureInfo(adventureId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} regionId Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdventureList(regionId: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getAdventureList(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} siteName Site Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConstantsBySiteName(siteName: string, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.getConstantsBySiteName(siteName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionList(options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.getRegionList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions(options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.getRegions(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegionsBysiteId(siteId: number, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.getRegionsBysiteId(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRulesBySiteId(siteId: number, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.getRulesBySiteId(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteList(options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.getSiteList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExodusAPIsApi - object-oriented interface
 * @export
 * @class ExodusAPIsApi
 * @extends {BaseAPI}
 */
export class ExodusAPIsApi extends BaseAPI {
    /**
     *
     * @param {number} adventureId Adventure ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getAdventureInfo(adventureId: number, options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getAdventureInfo(adventureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} regionId Region ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getAdventureList(regionId: number, options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getAdventureList(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} siteName Site Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getConstantsBySiteName(siteName: string, options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getConstantsBySiteName(siteName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getRegionList(options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getRegionList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getRegions(options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getRegionsBysiteId(siteId: number, options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getRegionsBysiteId(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getRulesBySiteId(siteId: number, options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getRulesBySiteId(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExodusAPIsApi
     */
    public getSiteList(options?: AxiosRequestConfig) {
        return ExodusAPIsApiFp(this.configuration).getSiteList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HUSAAPIsApi - axios parameter creator
 * @export
 */
export const HUSAAPIsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d0f15b1af046a8e16188381fef27782f: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getCategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchPage: async (string: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'string' is not null or undefined
            assertParamExists('doSearchPage', 'string', string)
            const localVarPath = `/husa/searchPage/{string}`
                .replace(`{${"string"}}`, encodeURIComponent(String(string)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getPosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} blockId Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockInfo: async (blockId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('getBlockInfo', 'blockId', blockId)
            const localVarPath = `/husa/getBlockInfo/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByCategoryId: async (categoryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getBlocksByCategoryId', 'categoryId', categoryId)
            const localVarPath = `/husa/getBlocksByCategoryId/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByPageId: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getBlocksByPageId', 'pageId', pageId)
            const localVarPath = `/husa/getBlocksByPageId/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} modelId Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDynamicPages: async (modelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getDynamicPages', 'modelId', modelId)
            const localVarPath = `/husa/getDynamicPages/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenuList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getMenus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageForTest: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getPageForTest', 'pageId', pageId)
            const localVarPath = `/husa/test/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageInfo: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getPageInfo', 'pageId', pageId)
            const localVarPath = `/husa/getPageInfo/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} postId Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById: async (postId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getPostById', 'postId', postId)
            const localVarPath = `/husa/getPostInfo/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo: async (productId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductInfo', 'productId', productId)
            const localVarPath = `/husa/getProductInfo/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getProducts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getRedirects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticPages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getStaticPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} tempId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateInfo: async (tempId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tempId' is not null or undefined
            assertParamExists('getTemplateInfo', 'tempId', tempId)
            const localVarPath = `/husa/getTemplateInfo/{tempId}`
                .replace(`{${"tempId"}}`, encodeURIComponent(String(tempId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [categoryId] Category ID
         * @param {string} [string] string
         * @param {string} [condition] condition: or/and, default: or
         * @param {Array<string>} [filters] filters array
         * @param {string} [sort] sort by newest / oldest
         * @param {string} [type] page type: product or support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProductByCategoryId: async (categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/searchProduct`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (string !== undefined) {
                localVarQueryParameter['string'] = string;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (filters) {
                localVarQueryParameter['filters[]'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HUSAAPIsApi - functional programming interface
 * @export
 */
export const HUSAAPIsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HUSAAPIsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d0f15b1af046a8e16188381fef27782f(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d0f15b1af046a8e16188381fef27782f(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doSearchPage(string: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doSearchPage(string, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPosts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPosts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} blockId Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockInfo(blockId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockInfo(blockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlocksByCategoryId(categoryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlocksByCategoryId(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlocksByPageId(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlocksByPageId(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} modelId Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDynamicPages(modelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDynamicPages(modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMenuList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMenuList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageForTest(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageForTest(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageInfo(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageInfo(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} postId Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostById(postId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostById(postId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductInfo(productId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductInfo(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRedirectList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRedirectList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaticPages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStaticPages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} tempId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateInfo(tempId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateInfo(tempId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} [categoryId] Category ID
         * @param {string} [string] string
         * @param {string} [condition] condition: or/and, default: or
         * @param {Array<string>} [filters] filters array
         * @param {string} [sort] sort by newest / oldest
         * @param {string} [type] page type: product or support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchProductByCategoryId(categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchProductByCategoryId(categoryId, string, condition, filters, sort, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HUSAAPIsApi - factory interface
 * @export
 */
export const HUSAAPIsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HUSAAPIsApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d0f15b1af046a8e16188381fef27782f(options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.d0f15b1af046a8e16188381fef27782f(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchPage(string: string, options?: any): AxiosPromise<void> {
            return localVarFp.doSearchPage(string, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPages(options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.getAllPages(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts(options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.getAllPosts(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} blockId Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockInfo(blockId: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.getBlockInfo(blockId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByCategoryId(categoryId: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.getBlocksByCategoryId(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByPageId(pageId: number, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.getBlocksByPageId(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} modelId Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDynamicPages(modelId: number, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.getDynamicPages(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenuList(options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.getMenuList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageForTest(pageId: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.getPageForTest(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageInfo(pageId: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.getPageInfo(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} postId Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById(postId: number, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.getPostById(postId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo(productId: number, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.getProductInfo(productId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductList(options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.getProductList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectList(options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.getRedirectList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingList(options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.getSettingList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticPages(options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.getStaticPages(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} tempId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateInfo(tempId: number, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.getTemplateInfo(tempId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateList(options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.getTemplateList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [categoryId] Category ID
         * @param {string} [string] string
         * @param {string} [condition] condition: or/and, default: or
         * @param {Array<string>} [filters] filters array
         * @param {string} [sort] sort by newest / oldest
         * @param {string} [type] page type: product or support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProductByCategoryId(categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.searchProductByCategoryId(categoryId, string, condition, filters, sort, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HUSAAPIsApi - object-oriented interface
 * @export
 * @class HUSAAPIsApi
 * @extends {BaseAPI}
 */
export class HUSAAPIsApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public d0f15b1af046a8e16188381fef27782f(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).d0f15b1af046a8e16188381fef27782f(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} string string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public doSearchPage(string: string, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).doSearchPage(string, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getAllPages(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getAllPages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getAllPosts(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getAllPosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} blockId Block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getBlockInfo(blockId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getBlockInfo(blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} categoryId Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getBlocksByCategoryId(categoryId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getBlocksByCategoryId(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getBlocksByPageId(pageId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getBlocksByPageId(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} modelId Model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getDynamicPages(modelId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getDynamicPages(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getMenuList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getMenuList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getPageForTest(pageId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getPageForTest(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getPageInfo(pageId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getPageInfo(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} postId Post ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getPostById(postId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getPostById(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} productId Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getProductInfo(productId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getProductInfo(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getProductList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getProductList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getRedirectList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getRedirectList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getSettingList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getSettingList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getStaticPages(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getStaticPages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} tempId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getTemplateInfo(tempId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getTemplateInfo(tempId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getTemplateList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getTemplateList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} [categoryId] Category ID
     * @param {string} [string] string
     * @param {string} [condition] condition: or/and, default: or
     * @param {Array<string>} [filters] filters array
     * @param {string} [sort] sort by newest / oldest
     * @param {string} [type] page type: product or support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public searchProductByCategoryId(categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).searchProductByCategoryId(categoryId, string, condition, filters, sort, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HistoryApi - axios parameter creator
 * @export
 */
export const HistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHistories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/getHistories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} modelName Model Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoriesByModelName: async (modelName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getHistoriesByModelName', 'modelName', modelName)
            const localVarPath = `/history/getHistories/{modelName}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} modelName Model Name
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryByModelNameModelId: async (modelName: string, modelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getHistoryByModelNameModelId', 'modelName', modelName)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getHistoryByModelNameModelId', 'modelId', modelId)
            const localVarPath = `/history/getHistory/{modelName}/{modelId}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {HistoryRequest} historyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTitleUpdate: async (historyRequest: HistoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'historyRequest' is not null or undefined
            assertParamExists('historyTitleUpdate', 'historyRequest', historyRequest)
            const localVarPath = `/history/titleUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(historyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id History ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHistory: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showHistory', 'id', id)
            const localVarPath = `/history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoryApi - functional programming interface
 * @export
 */
export const HistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HistoryApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllHistories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllHistories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} modelName Model Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoriesByModelName(modelName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoriesByModelName(modelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} modelName Model Name
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoryByModelNameModelId(modelName: string, modelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoryByModelNameModelId(modelName, modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {HistoryRequest} historyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historyTitleUpdate(historyRequest: HistoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.historyTitleUpdate(historyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id History ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHistory(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHistory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HistoryApi - factory interface
 * @export
 */
export const HistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HistoryApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHistories(options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.getAllHistories(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} modelName Model Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoriesByModelName(modelName: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.getHistoriesByModelName(modelName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} modelName Model Name
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryByModelNameModelId(modelName: string, modelId: number, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.getHistoryByModelNameModelId(modelName, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {HistoryRequest} historyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTitleUpdate(historyRequest: HistoryRequest, options?: any): AxiosPromise<any> {
            return localVarFp.historyTitleUpdate(historyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id History ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHistory(id: number, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.showHistory(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HistoryApi - object-oriented interface
 * @export
 * @class HistoryApi
 * @extends {BaseAPI}
 */
export class HistoryApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getAllHistories(options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getAllHistories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} modelName Model Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getHistoriesByModelName(modelName: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getHistoriesByModelName(modelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} modelName Model Name
     * @param {number} modelId Model Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getHistoryByModelNameModelId(modelName: string, modelId: number, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getHistoryByModelNameModelId(modelName, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {HistoryRequest} historyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public historyTitleUpdate(historyRequest: HistoryRequest, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).historyTitleUpdate(historyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id History ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public showHistory(id: number, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).showHistory(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _288ae9e127972bc1367d0af34297f27c: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_288ae9e127972bc1367d0af34297f27c', 'id', id)
            const localVarPath = `/media/deleteMedia/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMedia: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadMedia', 'id', id)
            const localVarPath = `/media/downloadMedia/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} mediaTypeId
         * @param {any} file file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMedia: async (mediaTypeId: number, file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaTypeId' is not null or undefined
            assertParamExists('uploadMedia', 'mediaTypeId', mediaTypeId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadMedia', 'file', file)
            const localVarPath = `/media/uploadMedia`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (mediaTypeId !== undefined) {
                localVarFormParams.append('media_type_id', mediaTypeId as any);
            }

            if (file !== undefined) {
                localVarFormParams.append('file', new Blob([JSON.stringify(file)], { type: "application/json", }));
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _288ae9e127972bc1367d0af34297f27c(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._288ae9e127972bc1367d0af34297f27c(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMedia(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMedia(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} mediaTypeId
         * @param {any} file file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMedia(mediaTypeId: number, file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Media>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMedia(mediaTypeId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         *
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _288ae9e127972bc1367d0af34297f27c(id: number, options?: any): AxiosPromise<any> {
            return localVarFp._288ae9e127972bc1367d0af34297f27c(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Media ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMedia(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.downloadMedia(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} mediaTypeId
         * @param {any} file file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMedia(mediaTypeId: number, file: any, options?: any): AxiosPromise<Media> {
            return localVarFp.uploadMedia(mediaTypeId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     *
     * @param {number} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public _288ae9e127972bc1367d0af34297f27c(id: number, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration)._288ae9e127972bc1367d0af34297f27c(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Media ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public downloadMedia(id: number, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration).downloadMedia(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} mediaTypeId
     * @param {any} file file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public uploadMedia(mediaTypeId: number, file: any, options?: AxiosRequestConfig) {
        return MediaApiFp(this.configuration).uploadMedia(mediaTypeId, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaTypeApi - axios parameter creator
 * @export
 */
export const MediaTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _0df5be1eea3e1425a62af192ccf1a514: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mediatype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {MediaType} mediaType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b1a66a80eeeaf7177f395b0f3652e457: async (id: number, mediaType: MediaType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('b1a66a80eeeaf7177f395b0f3652e457', 'id', id)
            // verify required parameter 'mediaType' is not null or undefined
            assertParamExists('b1a66a80eeeaf7177f395b0f3652e457', 'mediaType', mediaType)
            const localVarPath = `/mediatype/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {MediaType} mediaType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cecdbcc2202fc94e01edcf61f8f89119: async (mediaType: MediaType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaType' is not null or undefined
            assertParamExists('cecdbcc2202fc94e01edcf61f8f89119', 'mediaType', mediaType)
            const localVarPath = `/mediatype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        e38550531275a28f7911f967a9bdd3f9: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('e38550531275a28f7911f967a9bdd3f9', 'id', id)
            const localVarPath = `/mediatype/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ebb7786f5d04ac4384dd799a77052087: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ebb7786f5d04ac4384dd799a77052087', 'id', id)
            const localVarPath = `/mediatype/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaTypeApi - functional programming interface
 * @export
 */
export const MediaTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaTypeApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _0df5be1eea3e1425a62af192ccf1a514(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._0df5be1eea3e1425a62af192ccf1a514(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {MediaType} mediaType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async b1a66a80eeeaf7177f395b0f3652e457(id: number, mediaType: MediaType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.b1a66a80eeeaf7177f395b0f3652e457(id, mediaType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {MediaType} mediaType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cecdbcc2202fc94e01edcf61f8f89119(mediaType: MediaType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cecdbcc2202fc94e01edcf61f8f89119(mediaType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async e38550531275a28f7911f967a9bdd3f9(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.e38550531275a28f7911f967a9bdd3f9(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ebb7786f5d04ac4384dd799a77052087(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ebb7786f5d04ac4384dd799a77052087(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaTypeApi - factory interface
 * @export
 */
export const MediaTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaTypeApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _0df5be1eea3e1425a62af192ccf1a514(options?: any): AxiosPromise<InlineResponse20026> {
            return localVarFp._0df5be1eea3e1425a62af192ccf1a514(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {MediaType} mediaType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b1a66a80eeeaf7177f395b0f3652e457(id: number, mediaType: MediaType, options?: any): AxiosPromise<MediaType> {
            return localVarFp.b1a66a80eeeaf7177f395b0f3652e457(id, mediaType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {MediaType} mediaType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cecdbcc2202fc94e01edcf61f8f89119(mediaType: MediaType, options?: any): AxiosPromise<MediaType> {
            return localVarFp.cecdbcc2202fc94e01edcf61f8f89119(mediaType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        e38550531275a28f7911f967a9bdd3f9(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.e38550531275a28f7911f967a9bdd3f9(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Media Type ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ebb7786f5d04ac4384dd799a77052087(id: number, options?: any): AxiosPromise<InlineResponse20027> {
            return localVarFp.ebb7786f5d04ac4384dd799a77052087(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaTypeApi - object-oriented interface
 * @export
 * @class MediaTypeApi
 * @extends {BaseAPI}
 */
export class MediaTypeApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaTypeApi
     */
    public _0df5be1eea3e1425a62af192ccf1a514(options?: AxiosRequestConfig) {
        return MediaTypeApiFp(this.configuration)._0df5be1eea3e1425a62af192ccf1a514(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Media Type ID
     * @param {MediaType} mediaType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaTypeApi
     */
    public b1a66a80eeeaf7177f395b0f3652e457(id: number, mediaType: MediaType, options?: AxiosRequestConfig) {
        return MediaTypeApiFp(this.configuration).b1a66a80eeeaf7177f395b0f3652e457(id, mediaType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {MediaType} mediaType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaTypeApi
     */
    public cecdbcc2202fc94e01edcf61f8f89119(mediaType: MediaType, options?: AxiosRequestConfig) {
        return MediaTypeApiFp(this.configuration).cecdbcc2202fc94e01edcf61f8f89119(mediaType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Media Type ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaTypeApi
     */
    public e38550531275a28f7911f967a9bdd3f9(id: number, options?: AxiosRequestConfig) {
        return MediaTypeApiFp(this.configuration).e38550531275a28f7911f967a9bdd3f9(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Media Type ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaTypeApi
     */
    public ebb7786f5d04ac4384dd799a77052087(id: number, options?: AxiosRequestConfig) {
        return MediaTypeApiFp(this.configuration).ebb7786f5d04ac4384dd799a77052087(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MenuApi - axios parameter creator
 * @export
 */
export const MenuApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Menu} menu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMenu: async (menu: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menu' is not null or undefined
            assertParamExists('addMenu', 'menu', menu)
            const localVarPath = `/menu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMenu: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMenu', 'id', id)
            const localVarPath = `/menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenu: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMenu', 'id', id)
            const localVarPath = `/menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/menu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {Menu} menu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMenu: async (id: number, menu: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMenu', 'id', id)
            // verify required parameter 'menu' is not null or undefined
            assertParamExists('updateMenu', 'menu', menu)
            const localVarPath = `/menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MenuApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Menu} menu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMenu(menu: Menu, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMenu(menu, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMenu(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMenu(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMenu(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMenu(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async menuList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.menuList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {Menu} menu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMenu(id: number, menu: Menu, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMenu(id, menu, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MenuApiFp(configuration)
    return {
        /**
         *
         * @param {Menu} menu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMenu(menu: Menu, options?: any): AxiosPromise<Menu> {
            return localVarFp.addMenu(menu, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMenu(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteMenu(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenu(id: number, options?: any): AxiosPromise<InlineResponse20028> {
            return localVarFp.getMenu(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuList(options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.menuList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Menu ID
         * @param {Menu} menu
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMenu(id: number, menu: Menu, options?: any): AxiosPromise<Menu> {
            return localVarFp.updateMenu(id, menu, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI {
    /**
     *
     * @param {Menu} menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public addMenu(menu: Menu, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).addMenu(menu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Menu ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public deleteMenu(id: number, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).deleteMenu(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Menu ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public getMenu(id: number, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).getMenu(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public menuList(options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).menuList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Menu ID
     * @param {Menu} menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public updateMenu(id: number, menu: Menu, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).updateMenu(id, menu, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotification', 'id', id)
            const localVarPath = `/notification/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Notification} notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNotification: async (notification: Notification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('importNotification', 'notification', notification)
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNotification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showNotification', 'id', id)
            const localVarPath = `/notification/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Notification ID
         * @param {Notification} notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (id: number, notification: Notification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNotification', 'id', id)
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('updateNotification', 'notification', notification)
            const localVarPath = `/notification/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {Notification} notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importNotification(notification: Notification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNotification(notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showNotification(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Notification ID
         * @param {Notification} notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(id: number, notification: Notification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(id, notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         *
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Notification} notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNotification(notification: Notification, options?: any): AxiosPromise<Notification> {
            return localVarFp.importNotification(notification, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationList(options?: any): AxiosPromise<InlineResponse20029> {
            return localVarFp.notificationList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNotification(id: number, options?: any): AxiosPromise<InlineResponse20030> {
            return localVarFp.showNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Notification ID
         * @param {Notification} notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(id: number, notification: Notification, options?: any): AxiosPromise<Notification> {
            return localVarFp.updateNotification(id, notification, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     *
     * @param {number} id Notification ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public deleteNotification(id: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).deleteNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Notification} notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public importNotification(notification: Notification, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).importNotification(notification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notificationList(options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notificationList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Notification ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public showNotification(id: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).showNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Notification ID
     * @param {Notification} notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public updateNotification(id: number, notification: Notification, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).updateNotification(id, notification, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PageApi - axios parameter creator
 * @export
 */
export const PageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPage: async (page: Page, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('addPage', 'page', page)
            const localVarPath = `/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(page, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePage', 'id', id)
            const localVarPath = `/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doDeploy: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/page/doDeploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListAllPages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/page/getSummaryPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDynamicPage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/page/getDynamicPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getPage', 'pageId', pageId)
            const localVarPath = `/page/getPage/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} modelType Model Type
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageByModelTypeModelId: async (modelType: string, modelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelType' is not null or undefined
            assertParamExists('getPageByModelTypeModelId', 'modelType', modelType)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getPageByModelTypeModelId', 'modelId', modelId)
            const localVarPath = `/page/getPage/{modelType}/{modelId}`
                .replace(`{${"modelType"}}`, encodeURIComponent(String(modelType)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageDraft: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPageDraft', 'id', id)
            const localVarPath = `/page/getPageDraft/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductRoutes: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductRoutes', 'id', id)
            const localVarPath = `/page/getProductRoutes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPage: async (page: Page, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('importPage', 'page', page)
            const localVarPath = `/page/importPage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(page, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockPage: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('lockPage', 'pageId', pageId)
            const localVarPath = `/page/lock/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showPage', 'id', id)
            const localVarPath = `/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unLockPage: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('unLockPage', 'pageId', pageId)
            const localVarPath = `/page/unLock/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Page ID
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage: async (id: number, page: Page, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePage', 'id', id)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('updatePage', 'page', page)
            const localVarPath = `/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(page, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {Draft} draft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageDraft: async (pageId: number, draft: Draft, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('updatePageDraft', 'pageId', pageId)
            // verify required parameter 'draft' is not null or undefined
            assertParamExists('updatePageDraft', 'draft', draft)
            const localVarPath = `/page/saveDraft/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(draft, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {Widgets} widgets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageWidgets: async (pageId: number, widgets: Widgets, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('updatePageWidgets', 'pageId', pageId)
            // verify required parameter 'widgets' is not null or undefined
            assertParamExists('updatePageWidgets', 'widgets', widgets)
            const localVarPath = `/page/saveWidgets/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(widgets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPage(page: Page, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPage(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doDeploy(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doDeploy(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListAllPages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListAllPages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListDynamicPage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListDynamicPage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPage(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPage(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} modelType Model Type
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageByModelTypeModelId(modelType: string, modelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageByModelTypeModelId(modelType, modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageDraft(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageDraft(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductRoutes(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductRoutes(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importPage(page: Page, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importPage(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockPage(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockPage(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showPage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showPage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unLockPage(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unLockPage(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Page ID
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePage(id: number, page: Page, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePage(id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {Draft} draft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePageDraft(pageId: number, draft: Draft, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePageDraft(pageId, draft, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {Widgets} widgets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePageWidgets(pageId: number, widgets: Widgets, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePageWidgets(pageId, widgets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageApiFp(configuration)
    return {
        /**
         *
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPage(page: Page, options?: any): AxiosPromise<Page> {
            return localVarFp.addPage(page, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deletePage(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doDeploy(options?: any): AxiosPromise<any> {
            return localVarFp.doDeploy(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListAllPages(options?: any): AxiosPromise<InlineResponse20033> {
            return localVarFp.getListAllPages(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDynamicPage(options?: any): AxiosPromise<InlineResponse20033> {
            return localVarFp.getListDynamicPage(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage(pageId: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.getPage(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} modelType Model Type
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageByModelTypeModelId(modelType: string, modelId: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.getPageByModelTypeModelId(modelType, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageDraft(id: number, options?: any): AxiosPromise<InlineResponse20032> {
            return localVarFp.getPageDraft(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductRoutes(id: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.getProductRoutes(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importPage(page: Page, options?: any): AxiosPromise<Page> {
            return localVarFp.importPage(page, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockPage(pageId: number, options?: any): AxiosPromise<any> {
            return localVarFp.lockPage(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageList(options?: any): AxiosPromise<InlineResponse20031> {
            return localVarFp.pageList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPage(id: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.showPage(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unLockPage(pageId: number, options?: any): AxiosPromise<any> {
            return localVarFp.unLockPage(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Page ID
         * @param {Page} page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage(id: number, page: Page, options?: any): AxiosPromise<Page> {
            return localVarFp.updatePage(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {Draft} draft
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageDraft(pageId: number, draft: Draft, options?: any): AxiosPromise<any> {
            return localVarFp.updatePageDraft(pageId, draft, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {Widgets} widgets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageWidgets(pageId: number, widgets: Widgets, options?: any): AxiosPromise<any> {
            return localVarFp.updatePageWidgets(pageId, widgets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI {
    /**
     *
     * @param {Page} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public addPage(page: Page, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).addPage(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public deletePage(id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).deletePage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public doDeploy(options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).doDeploy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getListAllPages(options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getListAllPages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getListDynamicPage(options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getListDynamicPage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getPage(pageId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getPage(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {string} modelType Model Type
     * @param {number} modelId Model Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getPageByModelTypeModelId(modelType: string, modelId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getPageByModelTypeModelId(modelType, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getPageDraft(id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getPageDraft(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getProductRoutes(id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getProductRoutes(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {Page} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public importPage(page: Page, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).importPage(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public lockPage(pageId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).lockPage(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pageList(options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).pageList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public showPage(id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).showPage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public unLockPage(pageId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).unLockPage(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Page ID
     * @param {Page} page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePage(id: number, page: Page, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).updatePage(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {Draft} draft
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePageDraft(pageId: number, draft: Draft, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).updatePageDraft(pageId, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {Widgets} widgets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePageWidgets(pageId: number, widgets: Widgets, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).updatePageWidgets(pageId, widgets, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostApi - axios parameter creator
 * @export
 */
export const PostApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Post} post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPost: async (post: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            assertParamExists('addPost', 'post', post)
            const localVarPath = `/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePost', 'id', id)
            const localVarPath = `/post/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPost', 'id', id)
            const localVarPath = `/post/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByCategoryId: async (categoryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getPostsByCategoryId', 'categoryId', categoryId)
            const localVarPath = `/post/getPostsByCategoryId/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Post ID
         * @param {Post} post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost: async (id: number, post: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePost', 'id', id)
            // verify required parameter 'post' is not null or undefined
            assertParamExists('updatePost', 'post', post)
            const localVarPath = `/post/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostApi - functional programming interface
 * @export
 */
export const PostApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Post} post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPost(post: Post, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPost(post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostsByCategoryId(categoryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsByCategoryId(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Post ID
         * @param {Post} post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePost(id: number, post: Post, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(id, post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PostApi - factory interface
 * @export
 */
export const PostApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostApiFp(configuration)
    return {
        /**
         *
         * @param {Post} post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPost(post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.addPost(post, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deletePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPost(id: number, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.getPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByCategoryId(categoryId: number, options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.getPostsByCategoryId(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.postList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Post ID
         * @param {Post} post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost(id: number, post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.updatePost(id, post, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostApi - object-oriented interface
 * @export
 * @class PostApi
 * @extends {BaseAPI}
 */
export class PostApi extends BaseAPI {
    /**
     *
     * @param {Post} post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public addPost(post: Post, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).addPost(post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Post ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public deletePost(id: number, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).deletePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Post ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getPost(id: number, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} categoryId Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getPostsByCategoryId(categoryId: number, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getPostsByCategoryId(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public postList(options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).postList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Post ID
     * @param {Post} post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public updatePost(id: number, post: Post, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).updatePost(id, post, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Product} product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct: async (product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('addProduct', 'product', product)
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Product ID
         * @param {Product} product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: number, product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('updateProduct', 'product', product)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Product} product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProduct(product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProduct(product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Product ID
         * @param {Product} product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: number, product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         *
         * @param {Product} product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.addProduct(product, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: number, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.getProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productList(options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.productList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Product ID
         * @param {Product} product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.updateProduct(id, product, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     *
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addProduct(product: Product, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).addProduct(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProduct(id: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProduct(id: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productList(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Product ID
     * @param {Product} product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProduct(id: number, product: Product, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).updateProduct(id, product, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RedirectApi - axios parameter creator
 * @export
 */
export const RedirectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Redirect} redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRedirect: async (redirect: Redirect, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirect' is not null or undefined
            assertParamExists('addRedirect', 'redirect', redirect)
            const localVarPath = `/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redirect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRedirect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRedirect', 'id', id)
            const localVarPath = `/redirect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRedirect', 'id', id)
            const localVarPath = `/redirect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectsByPageId: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getRedirectsByPageId', 'pageId', pageId)
            const localVarPath = `/redirect/getRedirects/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {Redirect} redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRedirect: async (id: number, redirect: Redirect, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRedirect', 'id', id)
            // verify required parameter 'redirect' is not null or undefined
            assertParamExists('updateRedirect', 'redirect', redirect)
            const localVarPath = `/redirect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redirect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RedirectApi - functional programming interface
 * @export
 */
export const RedirectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RedirectApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Redirect} redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRedirect(redirect: Redirect, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Redirect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRedirect(redirect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRedirect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRedirect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRedirect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRedirect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRedirectsByPageId(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRedirectsByPageId(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {Redirect} redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRedirect(id: number, redirect: Redirect, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Redirect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRedirect(id, redirect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RedirectApi - factory interface
 * @export
 */
export const RedirectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RedirectApiFp(configuration)
    return {
        /**
         *
         * @param {Redirect} redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRedirect(redirect: Redirect, options?: any): AxiosPromise<Redirect> {
            return localVarFp.addRedirect(redirect, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRedirect(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteRedirect(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirect(id: number, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.getRedirect(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectsByPageId(pageId: number, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.getRedirectsByPageId(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectList(options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.redirectList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Redirect ID
         * @param {Redirect} redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRedirect(id: number, redirect: Redirect, options?: any): AxiosPromise<Redirect> {
            return localVarFp.updateRedirect(id, redirect, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RedirectApi - object-oriented interface
 * @export
 * @class RedirectApi
 * @extends {BaseAPI}
 */
export class RedirectApi extends BaseAPI {
    /**
     *
     * @param {Redirect} redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public addRedirect(redirect: Redirect, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).addRedirect(redirect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Redirect ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public deleteRedirect(id: number, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).deleteRedirect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Redirect ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public getRedirect(id: number, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).getRedirect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public getRedirectsByPageId(pageId: number, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).getRedirectsByPageId(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public redirectList(options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).redirectList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Redirect ID
     * @param {Redirect} redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public updateRedirect(id: number, redirect: Redirect, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).updateRedirect(id, redirect, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegionApi - axios parameter creator
 * @export
 */
export const RegionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Region} region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRegion: async (region: Region, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('addRegion', 'region', region)
            const localVarPath = `/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegion: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRegion', 'id', id)
            const localVarPath = `/region/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBySiteId: async (siteId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('getBySiteId', 'siteId', siteId)
            const localVarPath = `/region/getBySiteId/{siteId}`
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRegion', 'id', id)
            const localVarPath = `/region/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/region`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Region ID
         * @param {Region} region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegion: async (id: number, region: Region, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRegion', 'id', id)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('updateRegion', 'region', region)
            const localVarPath = `/region/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionApi - functional programming interface
 * @export
 */
export const RegionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Region} region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRegion(region: Region, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRegion(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRegion(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRegion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBySiteId(siteId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBySiteId(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegion(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Region ID
         * @param {Region} region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRegion(id: number, region: Region, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRegion(id, region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegionApi - factory interface
 * @export
 */
export const RegionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionApiFp(configuration)
    return {
        /**
         *
         * @param {Region} region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRegion(region: Region, options?: any): AxiosPromise<Region> {
            return localVarFp.addRegion(region, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegion(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteRegion(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBySiteId(siteId: number, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.getBySiteId(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion(id: number, options?: any): AxiosPromise<InlineResponse20036> {
            return localVarFp.getRegion(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionList(options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.regionList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Region ID
         * @param {Region} region
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegion(id: number, region: Region, options?: any): AxiosPromise<Region> {
            return localVarFp.updateRegion(id, region, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionApi - object-oriented interface
 * @export
 * @class RegionApi
 * @extends {BaseAPI}
 */
export class RegionApi extends BaseAPI {
    /**
     *
     * @param {Region} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public addRegion(region: Region, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).addRegion(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Region ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public deleteRegion(id: number, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).deleteRegion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public getBySiteId(siteId: number, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).getBySiteId(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Region ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public getRegion(id: number, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).getRegion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public regionList(options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).regionList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Region ID
     * @param {Region} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public updateRegion(id: number, region: Region, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).updateRegion(id, region, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuleApi - axios parameter creator
 * @export
 */
export const RuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Rule} rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRules: async (rule: Rule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('addRules', 'rule', rule)
            const localVarPath = `/rule/addRules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRule', 'id', id)
            const localVarPath = `/rule/deleteRules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRule', 'id', id)
            const localVarPath = `/rule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules: async (siteId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('getRules', 'siteId', siteId)
            const localVarPath = `/rule/getRules/{siteId}`
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {Rule} rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRules: async (id: number, rule: Rule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRules', 'id', id)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateRules', 'rule', rule)
            const localVarPath = `/rule/updateRules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleApi - functional programming interface
 * @export
 */
export const RuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Rule} rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRules(rule: Rule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRules(rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRules(siteId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRules(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rulesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rulesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {Rule} rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRules(id: number, rule: Rule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRules(id, rule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuleApi - factory interface
 * @export
 */
export const RuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuleApiFp(configuration)
    return {
        /**
         *
         * @param {Rule} rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRules(rule: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.addRules(rule, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(id: number, options?: any): AxiosPromise<InlineResponse20037> {
            return localVarFp.getRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(siteId: number, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.getRules(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulesList(options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.rulesList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Rule ID
         * @param {Rule} rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRules(id: number, rule: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.updateRules(id, rule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RuleApi - object-oriented interface
 * @export
 * @class RuleApi
 * @extends {BaseAPI}
 */
export class RuleApi extends BaseAPI {
    /**
     *
     * @param {Rule} rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public addRules(rule: Rule, options?: AxiosRequestConfig) {
        return RuleApiFp(this.configuration).addRules(rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public deleteRule(id: number, options?: AxiosRequestConfig) {
        return RuleApiFp(this.configuration).deleteRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public getRule(id: number, options?: AxiosRequestConfig) {
        return RuleApiFp(this.configuration).getRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public getRules(siteId: number, options?: AxiosRequestConfig) {
        return RuleApiFp(this.configuration).getRules(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public rulesList(options?: AxiosRequestConfig) {
        return RuleApiFp(this.configuration).rulesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Rule ID
     * @param {Rule} rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public updateRules(id: number, rule: Rule, options?: AxiosRequestConfig) {
        return RuleApiFp(this.configuration).updateRules(id, rule, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SectionApi - axios parameter creator
 * @export
 */
export const SectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Section} section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSection: async (section: Section, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'section' is not null or undefined
            assertParamExists('addSection', 'section', section)
            const localVarPath = `/section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(section, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSection: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSection', 'id', id)
            const localVarPath = `/section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSection', 'id', id)
            const localVarPath = `/section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sectionList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Section ID
         * @param {Section} section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSection: async (id: number, section: Section, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSection', 'id', id)
            // verify required parameter 'section' is not null or undefined
            assertParamExists('updateSection', 'section', section)
            const localVarPath = `/section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(section, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SectionApi - functional programming interface
 * @export
 */
export const SectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SectionApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Section} section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSection(section: Section, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSection(section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSection(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSection(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sectionList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sectionList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Section ID
         * @param {Section} section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSection(id: number, section: Section, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSection(id, section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SectionApi - factory interface
 * @export
 */
export const SectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SectionApiFp(configuration)
    return {
        /**
         *
         * @param {Section} section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSection(section: Section, options?: any): AxiosPromise<Section> {
            return localVarFp.addSection(section, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSection(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection(id: number, options?: any): AxiosPromise<InlineResponse20039> {
            return localVarFp.getSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sectionList(options?: any): AxiosPromise<InlineResponse20038> {
            return localVarFp.sectionList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Section ID
         * @param {Section} section
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSection(id: number, section: Section, options?: any): AxiosPromise<Section> {
            return localVarFp.updateSection(id, section, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SectionApi - object-oriented interface
 * @export
 * @class SectionApi
 * @extends {BaseAPI}
 */
export class SectionApi extends BaseAPI {
    /**
     *
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public addSection(section: Section, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).addSection(section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Section ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public deleteSection(id: number, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).deleteSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Section ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public getSection(id: number, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).getSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public sectionList(options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).sectionList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Section ID
     * @param {Section} section
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public updateSection(id: number, section: Section, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).updateSection(id, section, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingApi - axios parameter creator
 * @export
 */
export const SettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Setting} setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSetting: async (setting: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('addSetting', 'setting', setting)
            const localVarPath = `/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSetting: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSetting', 'id', id)
            const localVarPath = `/setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSetting', 'id', id)
            const localVarPath = `/setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {Setting} setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (id: number, setting: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSetting', 'id', id)
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('updateSetting', 'setting', setting)
            const localVarPath = `/setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingApi - functional programming interface
 * @export
 */
export const SettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Setting} setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSetting(setting: Setting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSetting(setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSetting(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSetting(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetting(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetting(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {Setting} setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(id: number, setting: Setting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(id, setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingApi - factory interface
 * @export
 */
export const SettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingApiFp(configuration)
    return {
        /**
         *
         * @param {Setting} setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSetting(setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.addSetting(setting, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSetting(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteSetting(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(id: number, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.getSetting(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingList(options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.settingList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Setting ID
         * @param {Setting} setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(id: number, setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.updateSetting(id, setting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingApi - object-oriented interface
 * @export
 * @class SettingApi
 * @extends {BaseAPI}
 */
export class SettingApi extends BaseAPI {
    /**
     *
     * @param {Setting} setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public addSetting(setting: Setting, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).addSetting(setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Setting ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public deleteSetting(id: number, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).deleteSetting(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Setting ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public getSetting(id: number, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).getSetting(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public settingList(options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).settingList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Setting ID
     * @param {Setting} setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public updateSetting(id: number, setting: Setting, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).updateSetting(id, setting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SiteApi - axios parameter creator
 * @export
 */
export const SiteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Site} site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSite: async (site: Site, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('addSite', 'site', site)
            const localVarPath = `/site`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSite: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSite', 'id', id)
            const localVarPath = `/site/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSite: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSite', 'id', id)
            const localVarPath = `/site/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteStatus: async (siteId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('getSiteStatus', 'siteId', siteId)
            const localVarPath = `/site/getSiteStatus/{siteId}`
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} siteId site Id
         * @param {number} status status: Enable&#x3D;1, Disable&#x3D;0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSiteStatus: async (siteId: number, status: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('setSiteStatus', 'siteId', siteId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('setSiteStatus', 'status', status)
            const localVarPath = `/site/setSiteStatus/{siteId}/{status}`
                .replace(`{${"siteId"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/site`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Site ID
         * @param {Site} site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSite: async (id: number, site: Site, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSite', 'id', id)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('updateSite', 'site', site)
            const localVarPath = `/site/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteApi - functional programming interface
 * @export
 */
export const SiteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SiteApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Site} site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSite(site: Site, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSite(site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSite(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSite(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSite(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSite(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSiteStatus(siteId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSiteStatus(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} siteId site Id
         * @param {number} status status: Enable&#x3D;1, Disable&#x3D;0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSiteStatus(siteId: number, status: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSiteStatus(siteId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siteList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siteList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Site ID
         * @param {Site} site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSite(id: number, site: Site, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSite(id, site, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SiteApi - factory interface
 * @export
 */
export const SiteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SiteApiFp(configuration)
    return {
        /**
         *
         * @param {Site} site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSite(site: Site, options?: any): AxiosPromise<Site> {
            return localVarFp.addSite(site, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSite(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteSite(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSite(id: number, options?: any): AxiosPromise<InlineResponse20041> {
            return localVarFp.getSite(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSiteStatus(siteId: number, options?: any): AxiosPromise<InlineResponse20041> {
            return localVarFp.getSiteStatus(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} siteId site Id
         * @param {number} status status: Enable&#x3D;1, Disable&#x3D;0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSiteStatus(siteId: number, status: number, options?: any): AxiosPromise<any> {
            return localVarFp.setSiteStatus(siteId, status, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siteList(options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.siteList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Site ID
         * @param {Site} site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSite(id: number, site: Site, options?: any): AxiosPromise<Site> {
            return localVarFp.updateSite(id, site, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SiteApi - object-oriented interface
 * @export
 * @class SiteApi
 * @extends {BaseAPI}
 */
export class SiteApi extends BaseAPI {
    /**
     *
     * @param {Site} site
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public addSite(site: Site, options?: AxiosRequestConfig) {
        return SiteApiFp(this.configuration).addSite(site, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public deleteSite(id: number, options?: AxiosRequestConfig) {
        return SiteApiFp(this.configuration).deleteSite(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getSite(id: number, options?: AxiosRequestConfig) {
        return SiteApiFp(this.configuration).getSite(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getSiteStatus(siteId: number, options?: AxiosRequestConfig) {
        return SiteApiFp(this.configuration).getSiteStatus(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} siteId site Id
     * @param {number} status status: Enable&#x3D;1, Disable&#x3D;0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public setSiteStatus(siteId: number, status: number, options?: AxiosRequestConfig) {
        return SiteApiFp(this.configuration).setSiteStatus(siteId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public siteList(options?: AxiosRequestConfig) {
        return SiteApiFp(this.configuration).siteList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Site ID
     * @param {Site} site
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public updateSite(id: number, site: Site, options?: AxiosRequestConfig) {
        return SiteApiFp(this.configuration).updateSite(id, site, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {Template} template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate: async (template: Template, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'template' is not null or undefined
            assertParamExists('addTemplate', 'template', template)
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(template, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTemplate', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTemplate', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id Template ID
         * @param {Template} template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (id: number, template: Template, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTemplate', 'id', id)
            // verify required parameter 'template' is not null or undefined
            assertParamExists('updateTemplate', 'template', template)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(template, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {Template} template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTemplate(template: Template, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplate(template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {number} id Template ID
         * @param {Template} template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(id: number, template: Template, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(id, template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateApiFp(configuration)
    return {
        /**
         *
         * @param {Template} template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(template: Template, options?: any): AxiosPromise<Template> {
            return localVarFp.addTemplate(template, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(id: number, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.getTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.templateList(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id Template ID
         * @param {Template} template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(id: number, template: Template, options?: any): AxiosPromise<Template> {
            return localVarFp.updateTemplate(id, template, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     *
     * @param {Template} template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public addTemplate(template: Template, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).addTemplate(template, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public deleteTemplate(id: number, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).deleteTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getTemplate(id: number, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).getTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public templateList(options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).templateList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @param {number} id Template ID
     * @param {Template} template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public updateTemplate(id: number, template: Template, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).updateTemplate(id, template, options).then((request) => request(this.axios, this.basePath));
    }
}


