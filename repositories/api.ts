/* tslint:disable */
/* eslint-disable */
/**
 * IM CXM APIs Documentation
 * IM CXM OpenApi description
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Asset model
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'thumb'?: string;
}
/**
 * Asset Resource model
 * @export
 * @interface AssetResource
 */
export interface AssetResource {
    /**
     * 
     * @type {number}
     * @memberof AssetResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetResource
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetResource
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetResource
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetResource
     */
    'extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetResource
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetResource
     */
    'thumb'?: string;
}
/**
 * Block model
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * 
     * @type {number}
     * @memberof Block
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Block
     */
    'category_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'image'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Block
     */
    'structure'?: Array<object>;
}
/**
 * Block page model
 * @export
 * @interface BlockPage
 */
export interface BlockPage {
    /**
     * 
     * @type {number}
     * @memberof BlockPage
     */
    'page_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockPage
     */
    'block_id'?: number;
    /**
     * 
     * @type {object}
     * @memberof BlockPage
     */
    'props'?: object;
    /**
     * 
     * @type {number}
     * @memberof BlockPage
     */
    'order'?: number;
}
/**
 * Block page Resource model
 * @export
 * @interface BlockPageResource
 */
export interface BlockPageResource {
    /**
     * 
     * @type {number}
     * @memberof BlockPageResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlockPageResource
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockPageResource
     */
    'category_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockPageResource
     */
    'image'?: string;
    /**
     * 
     * @type {object}
     * @memberof BlockPageResource
     */
    'structure'?: object;
    /**
     * 
     * @type {number}
     * @memberof BlockPageResource
     */
    'order'?: number;
    /**
     * 
     * @type {object}
     * @memberof BlockPageResource
     */
    'props'?: object;
}
/**
 * Block Resource model
 * @export
 * @interface BlockResource
 */
export interface BlockResource {
    /**
     * 
     * @type {number}
     * @memberof BlockResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlockResource
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockResource
     */
    'category_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockResource
     */
    'image'?: string;
    /**
     * 
     * @type {object}
     * @memberof BlockResource
     */
    'structure'?: object;
}
/**
 * Category model
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'brand_id'?: number;
}
/**
 * Category Resource model
 * @export
 * @interface CategoryResource
 */
export interface CategoryResource {
    /**
     * 
     * @type {number}
     * @memberof CategoryResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryResource
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryResource
     */
    'brand_id'?: number;
}
/**
 * Draft model
 * @export
 * @interface Draft
 */
export interface Draft {
    /**
     * 
     * @type {number}
     * @memberof Draft
     */
    'page_id'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Draft
     */
    'page_draft'?: Array<object>;
}
/**
 * Dynamic Page Resource model
 * @export
 * @interface DynamicPageResource
 */
export interface DynamicPageResource {
    /**
     * 
     * @type {number}
     * @memberof DynamicPageResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DynamicPageResource
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DynamicPageResource
     */
    'route'?: string;
    /**
     * 
     * @type {string}
     * @memberof DynamicPageResource
     */
    'redirect'?: string;
    /**
     * 
     * @type {number}
     * @memberof DynamicPageResource
     */
    'brand_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DynamicPageResource
     */
    'model_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DynamicPageResource
     */
    'model_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof DynamicPageResource
     */
    'template_id'?: number;
}
/**
 * History model
 * @export
 * @interface History
 */
export interface History {
    /**
     * 
     * @type {number}
     * @memberof History
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof History
     */
    'model_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof History
     */
    'model_name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof History
     */
    'widgets'?: Array<object>;
}
/**
 * HistoryRequest body data
 * @export
 * @interface HistoryRequest
 */
export interface HistoryRequest {
    /**
     * 
     * @type {number}
     * @memberof HistoryRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoryRequest
     */
    'title'?: string;
}
/**
 * History Resource model
 * @export
 * @interface HistoryResource
 */
export interface HistoryResource {
    /**
     * 
     * @type {number}
     * @memberof HistoryResource
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof HistoryResource
     */
    'model_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoryResource
     */
    'model_name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof HistoryResource
     */
    'widgets'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof HistoryResource
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryResource
     */
    'updated_at'?: string;

    'title'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<AssetResource>}
     * @memberof InlineResponse200
     */
    'data'?: Array<AssetResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {AssetResource}
     * @memberof InlineResponse2001
     */
    'data'?: AssetResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {TemplateResource}
     * @memberof InlineResponse20010
     */
    'data'?: TemplateResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Array<ProductResource>}
     * @memberof InlineResponse20011
     */
    'data'?: Array<ProductResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {ProductResource}
     * @memberof InlineResponse20012
     */
    'data'?: ProductResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {Array<MenuResource>}
     * @memberof InlineResponse20013
     */
    'data'?: Array<MenuResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Array<RedirectResource>}
     * @memberof InlineResponse20014
     */
    'data'?: Array<RedirectResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {Array<SettingResource>}
     * @memberof InlineResponse20015
     */
    'data'?: Array<SettingResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {PostResource}
     * @memberof InlineResponse20016
     */
    'data'?: PostResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {HistoryResource}
     * @memberof InlineResponse20017
     */
    'data'?: HistoryResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {MenuResource}
     * @memberof InlineResponse20018
     */
    'data'?: MenuResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {Array<NotificationResource>}
     * @memberof InlineResponse20019
     */
    'data'?: Array<NotificationResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<BlockResource>}
     * @memberof InlineResponse2002
     */
    'data'?: Array<BlockResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {NotificationResource}
     * @memberof InlineResponse20020
     */
    'data'?: NotificationResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {Array<PageResource>}
     * @memberof InlineResponse20021
     */
    'data'?: Array<PageResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {PageDraftResource}
     * @memberof InlineResponse20022
     */
    'data'?: PageDraftResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {DynamicPageResource}
     * @memberof InlineResponse20023
     */
    'data'?: DynamicPageResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {Array<PostResource>}
     * @memberof InlineResponse20024
     */
    'data'?: Array<PostResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {RedirectResource}
     * @memberof InlineResponse20025
     */
    'data'?: RedirectResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {Array<SectionResource>}
     * @memberof InlineResponse20026
     */
    'data'?: Array<SectionResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * 
     * @type {SectionResource}
     * @memberof InlineResponse20027
     */
    'data'?: SectionResource;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {SettingResource}
     * @memberof InlineResponse20028
     */
    'data'?: SettingResource;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {BlockResource}
     * @memberof InlineResponse2003
     */
    'data'?: BlockResource;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<CategoryResource>}
     * @memberof InlineResponse2004
     */
    'data'?: Array<CategoryResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {CategoryResource}
     * @memberof InlineResponse2005
     */
    'data'?: CategoryResource;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {PageResource}
     * @memberof InlineResponse2006
     */
    'data'?: PageResource;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {PageListResource}
     * @memberof InlineResponse2007
     */
    'data'?: PageListResource;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<BlockPageResource>}
     * @memberof InlineResponse2008
     */
    'data'?: Array<BlockPageResource>;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {Array<TemplateResource>}
     * @memberof InlineResponse2009
     */
    'data'?: Array<TemplateResource>;
}
/**
 * Inquiry Resource model
 * @export
 * @interface InquiryResource
 */
export interface InquiryResource {
    /**
     * 
     * @type {string}
     * @memberof InquiryResource
     */
    'user_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InquiryResource
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof InquiryResource
     */
    'level'?: string;
    /**
     * 
     * @type {string}
     * @memberof InquiryResource
     */
    'application'?: string;
    /**
     * 
     * @type {Array<InquiryResourceBrands>}
     * @memberof InquiryResource
     */
    'brands'?: Array<InquiryResourceBrands>;
}
/**
 * 
 * @export
 * @interface InquiryResourceBrand
 */
export interface InquiryResourceBrand {
    /**
     * 
     * @type {string}
     * @memberof InquiryResourceBrand
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InquiryResourceBrand
     */
    'logo'?: string;
}
/**
 * 
 * @export
 * @interface InquiryResourceBrands
 */
export interface InquiryResourceBrands {
    /**
     * 
     * @type {InquiryResourceBrand}
     * @memberof InquiryResourceBrands
     */
    'brand'?: InquiryResourceBrand;
}
/**
 * Login model
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'password'?: string;
}
/**
 * Login Resource model
 * @export
 * @interface LoginResource
 */
export interface LoginResource {
    /**
     * 
     * @type {number}
     * @memberof LoginResource
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginResource
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResource
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResource
     */
    'level'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResource
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResource
     */
    'token_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResource
     */
    'expires_at'?: string;
}
/**
 * Menu model
 * @export
 * @interface Menu
 */
export interface Menu {
    /**
     * 
     * @type {number}
     * @memberof Menu
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Menu
     */
    'title'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Menu
     */
    'widgets'?: Array<object>;
}
/**
 * Menu Resource model
 * @export
 * @interface MenuResource
 */
export interface MenuResource {
    /**
     * 
     * @type {number}
     * @memberof MenuResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MenuResource
     */
    'title'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof MenuResource
     */
    'widgets'?: Array<object>;
}
/**
 * Notification model
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'text_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'background_color'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Notification
     */
    'page_Ids'?: Array<number>;
}
/**
 * Notification Page model
 * @export
 * @interface NotificationPage
 */
export interface NotificationPage {
    /**
     * 
     * @type {number}
     * @memberof NotificationPage
     */
    'notification_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof NotificationPage
     */
    'page_id'?: number;
}
/**
 * Notification Resource model
 * @export
 * @interface NotificationResource
 */
export interface NotificationResource {
    /**
     * 
     * @type {number}
     * @memberof NotificationResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NotificationResource
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationResource
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationResource
     */
    'text_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationResource
     */
    'background_color'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof NotificationResource
     */
    'page_Ids'?: Array<number>;
    /**
     * 
     * @type {Array<NotificationResourcePages>}
     * @memberof NotificationResource
     */
    'pages'?: Array<NotificationResourcePages>;
}
/**
 * 
 * @export
 * @interface NotificationResourcePages
 */
export interface NotificationResourcePages {
    /**
     * 
     * @type {string}
     * @memberof NotificationResourcePages
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof NotificationResourcePages
     */
    'title'?: number;
}
/**
 * Page model
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'route'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'redirect'?: string;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'fetchUrl'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Page
     */
    'meta'?: Array<object>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Page
     */
    'block_ids'?: Array<number>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Page
     */
    'draft'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Page
     */
    'widgets'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'brand_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'model_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Page
     */
    'model_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Page
     */
    'template_id'?: number;

    'locked_by'? : number;
}
/**
 * Page Draft Resource model
 * @export
 * @interface PageDraftResource
 */
export interface PageDraftResource {
    /**
     * 
     * @type {number}
     * @memberof PageDraftResource
     */
    'page_id'?: number;
    /**
     * 
     * @type {object}
     * @memberof PageDraftResource
     */
    'page_draft'?: object;
}
/**
 * Page Full Resource model
 * @export
 * @interface PageFullResource
 */
export interface PageFullResource {
    /**
     * 
     * @type {number}
     * @memberof PageFullResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageFullResource
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageFullResource
     */
    'route'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageFullResource
     */
    'fetchUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageFullResource
     */
    'meta'?: string;
    /**
     * 
     * @type {Array<PageFullResourceBlocks>}
     * @memberof PageFullResource
     */
    'blocks'?: Array<PageFullResourceBlocks>;
}
/**
 * 
 * @export
 * @interface PageFullResourceBlocks
 */
export interface PageFullResourceBlocks {
    /**
     * 
     * @type {number}
     * @memberof PageFullResourceBlocks
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageFullResourceBlocks
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageFullResourceBlocks
     */
    'category_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageFullResourceBlocks
     */
    'image'?: string;
    /**
     * 
     * @type {object}
     * @memberof PageFullResourceBlocks
     */
    'structure'?: object;
    /**
     * 
     * @type {object}
     * @memberof PageFullResourceBlocks
     */
    'props'?: object;
}
/**
 * Page List Resource model
 * @export
 * @interface PageListResource
 */
export interface PageListResource {
    /**
     * 
     * @type {number}
     * @memberof PageListResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageListResource
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageListResource
     */
    'route'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageListResource
     */
    'redirect'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageListResource
     */
    'fetchUrl'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof PageListResource
     */
    'meta'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof PageListResource
     */
    'widgets'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof PageListResource
     */
    'brand_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageListResource
     */
    'model_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageListResource
     */
    'model_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageListResource
     */
    'template_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageListResource
     */
    'locked_by'?: number;
}
/**
 * Page Resource model
 * @export
 * @interface PageResource
 */
export interface PageResource {
    /**
     * 
     * @type {number}
     * @memberof PageResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageResource
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageResource
     */
    'route'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageResource
     */
    'redirect'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageResource
     */
    'fetchUrl'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof PageResource
     */
    'meta'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof PageResource
     */
    'draft'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof PageResource
     */
    'widgets'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof PageResource
     */
    'brand_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResource
     */
    'model_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageResource
     */
    'model_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageResource
     */
    'template_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResource
     */
    'locked_by'?: number;
    /**
     * 
     * @type {Array<PageResourceNotifications>}
     * @memberof PageResource
     */
    'notifications'?: Array<PageResourceNotifications>;
}
/**
 * 
 * @export
 * @interface PageResourceNotifications
 */
export interface PageResourceNotifications {
    /**
     * 
     * @type {number}
     * @memberof PageResourceNotifications
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PageResourceNotifications
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageResourceNotifications
     */
    'text_color'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageResourceNotifications
     */
    'background_color'?: string;
}
/**
 * Post model
 * @export
 * @interface Post
 */
export interface Post {
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    'route'?: string;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    'category_id'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Post
     */
    'widgets'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Post
     */
    'meta'?: Array<object>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Post
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    'status'?: number;

    'page'? : Page
}
/**
 * Post Resource model
 * @export
 * @interface PostResource
 */
export interface PostResource {
    /**
     * 
     * @type {number}
     * @memberof PostResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostResource
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostResource
     */
    'route'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostResource
     */
    'category_id'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof PostResource
     */
    'widgets'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof PostResource
     */
    'meta'?: Array<object>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostResource
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PostResource
     */
    'status'?: number;
}
/**
 * Product model
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'product_id'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Product
     */
    'product_meta'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof Product
     */
    'product_content'?: Array<object>;
}
/**
 * Product Resource model
 * @export
 * @interface ProductResource
 */
export interface ProductResource {
    /**
     * 
     * @type {number}
     * @memberof ProductResource
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductResource
     */
    'product_id'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof ProductResource
     */
    'product_meta'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ProductResource
     */
    'product_content'?: Array<object>;
}
/**
 * Redirect model
 * @export
 * @interface Redirect
 */
export interface Redirect {
    /**
     * 
     * @type {number}
     * @memberof Redirect
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Redirect
     */
    'page_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Redirect
     */
    'source_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Redirect
     */
    'redirect_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Redirect
     */
    'redirect_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Redirect
     */
    'redirect_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof Redirect
     */
    'regex'?: string;
}
/**
 * Redirect Resource model
 * @export
 * @interface RedirectResource
 */
export interface RedirectResource {
    /**
     * 
     * @type {number}
     * @memberof RedirectResource
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof RedirectResource
     */
    'page_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedirectResource
     */
    'source_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectResource
     */
    'page_route'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectResource
     */
    'redirect_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectResource
     */
    'redirect_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof RedirectResource
     */
    'redirect_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedirectResource
     */
    'regex'?: string;
}
/**
 * Section model
 * @export
 * @interface Section
 */
export interface Section {
    /**
     * 
     * @type {number}
     * @memberof Section
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Section
     */
    'name'?: string;
}
/**
 * Section Resource model
 * @export
 * @interface SectionResource
 */
export interface SectionResource {
    /**
     * 
     * @type {number}
     * @memberof SectionResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SectionResource
     */
    'name'?: string;
}
/**
 * Setting model
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {number}
     * @memberof Setting
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'value'?: string;
}
/**
 * Setting Resource model
 * @export
 * @interface SettingResource
 */
export interface SettingResource {
    /**
     * 
     * @type {number}
     * @memberof SettingResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SettingResource
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingResource
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingResource
     */
    'value'?: string;
}
/**
 * Template model
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {number}
     * @memberof Template
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Template
     */
    'widgets'?: Array<object>;
}
/**
 * Template Resource model
 * @export
 * @interface TemplateResource
 */
export interface TemplateResource {
    /**
     * 
     * @type {number}
     * @memberof TemplateResource
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TemplateResource
     */
    'name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof TemplateResource
     */
    'widgets'?: Array<object>;
}
/**
 * User model
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'level'?: string;
}
/**
 * Widgets model
 * @export
 * @interface Widgets
 */
export interface Widgets {
    /**
     * 
     * @type {number}
     * @memberof Widgets
     */
    'page_id'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Widgets
     */
    'widgets'?: Array<object>;
}

/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Asset} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset: async (asset: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('addAsset', 'asset', asset)
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAsset', 'id', id)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchAsset: async (string: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'string' is not null or undefined
            assertParamExists('doSearchAsset', 'string', string)
            const localVarPath = `/asset/searchAsset/{string}`
                .replace(`{${"string"}}`, encodeURIComponent(String(string)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAsset', 'id', id)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {Asset} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (id: number, asset: Asset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAsset', 'id', id)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('updateAsset', 'asset', asset)
            const localVarPath = `/asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Asset} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAsset(asset: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAsset(asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsset(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doSearchAsset(string: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doSearchAsset(string, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {Asset} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(id: number, asset: Asset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(id, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetApiFp(configuration)
    return {
        /**
         * 
         * @param {Asset} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset(asset: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.addAsset(asset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetList(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.assetList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteAsset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchAsset(string: string, options?: any): AxiosPromise<void> {
            return localVarFp.doSearchAsset(string, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(id: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getAsset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Asset ID
         * @param {Asset} asset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(id: number, asset: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.updateAsset(id, asset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * 
     * @param {Asset} asset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public addAsset(asset: Asset, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).addAsset(asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetList(options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).assetList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Asset ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAsset(id: number, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).deleteAsset(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} string string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public doSearchAsset(string: string, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).doSearchAsset(string, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Asset ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAsset(id: number, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).getAsset(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Asset ID
     * @param {Asset} asset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(id: number, asset: Asset, options?: AxiosRequestConfig) {
        return AssetApiFp(this.configuration).updateAsset(id, asset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/getUserInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} publicKey public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInquiry: async (publicKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicKey' is not null or undefined
            assertParamExists('userInquiry', 'publicKey', publicKey)
            const localVarPath = `/auth/inquiry/{publicKey}`
                .replace(`{${"publicKey"}}`, encodeURIComponent(String(publicKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} publicKey public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInquiry(publicKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InquiryResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInquiry(publicKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<any> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} publicKey public Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInquiry(publicKey: string, options?: any): AxiosPromise<InquiryResource> {
            return localVarFp.userInquiry(publicKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getUserInfo(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} publicKey public Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public userInquiry(publicKey: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).userInquiry(publicKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockApi - axios parameter creator
 * @export
 */
export const BlockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBlock: async (block: Block, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'block' is not null or undefined
            assertParamExists('addBlock', 'block', block)
            const localVarPath = `/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(block, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlock: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBlock', 'id', id)
            const localVarPath = `/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlock', 'id', id)
            const localVarPath = `/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlock: async (id: number, block: Block, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBlock', 'id', id)
            // verify required parameter 'block' is not null or undefined
            assertParamExists('updateBlock', 'block', block)
            const localVarPath = `/block/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(block, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BlockPage} blockPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProps: async (blockPage: BlockPage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockPage' is not null or undefined
            assertParamExists('updateProps', 'blockPage', blockPage)
            const localVarPath = `/block/updateProps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockPage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockApi - functional programming interface
 * @export
 */
export const BlockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBlock(block: Block, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBlock(block, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlock(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlock(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlock(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlock(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlock(id: number, block: Block, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Block>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBlock(id, block, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BlockPage} blockPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProps(blockPage: BlockPage, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProps(blockPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockApi - factory interface
 * @export
 */
export const BlockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockApiFp(configuration)
    return {
        /**
         * 
         * @param {Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBlock(block: Block, options?: any): AxiosPromise<Block> {
            return localVarFp.addBlock(block, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockList(options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.blockList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlock(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteBlock(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlock(id: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getBlock(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Block ID
         * @param {Block} block 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlock(id: number, block: Block, options?: any): AxiosPromise<Block> {
            return localVarFp.updateBlock(id, block, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BlockPage} blockPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProps(blockPage: BlockPage, options?: any): AxiosPromise<any> {
            return localVarFp.updateProps(blockPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockApi - object-oriented interface
 * @export
 * @class BlockApi
 * @extends {BaseAPI}
 */
export class BlockApi extends BaseAPI {
    /**
     * 
     * @param {Block} block 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public addBlock(block: Block, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).addBlock(block, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public blockList(options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).blockList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public deleteBlock(id: number, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).deleteBlock(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public getBlock(id: number, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).getBlock(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Block ID
     * @param {Block} block 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public updateBlock(id: number, block: Block, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).updateBlock(id, block, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BlockPage} blockPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public updateProps(blockPage: BlockPage, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).updateProps(blockPage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _062b0e17b0b265231ad33ece1785b1fe: async (brandId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('_062b0e17b0b265231ad33ece1785b1fe', 'brandId', brandId)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _0fd985657bea3b2f3a919bdc16fec5b9: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_0fd985657bea3b2f3a919bdc16fec5b9', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Category ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _2aeef67a0c5f4a9161985387cab71ccc: async (brandId: number, id: number, category: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('_2aeef67a0c5f4a9161985387cab71ccc', 'brandId', brandId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_2aeef67a0c5f4a9161985387cab71ccc', 'id', id)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('_2aeef67a0c5f4a9161985387cab71ccc', 'category', category)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _8a437c9b58cb5726b37615e8a5a9857c: async (brandId: number, category: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('_8a437c9b58cb5726b37615e8a5a9857c', 'brandId', brandId)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('_8a437c9b58cb5726b37615e8a5a9857c', 'category', category)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        c22ffb01fe96cd5baf6a4174466b2672: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('c22ffb01fe96cd5baf6a4174466b2672', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _062b0e17b0b265231ad33ece1785b1fe(brandId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._062b0e17b0b265231ad33ece1785b1fe(brandId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _0fd985657bea3b2f3a919bdc16fec5b9(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._0fd985657bea3b2f3a919bdc16fec5b9(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Category ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _2aeef67a0c5f4a9161985387cab71ccc(brandId: number, id: number, category: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._2aeef67a0c5f4a9161985387cab71ccc(brandId, id, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _8a437c9b58cb5726b37615e8a5a9857c(brandId: number, category: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._8a437c9b58cb5726b37615e8a5a9857c(brandId, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async c22ffb01fe96cd5baf6a4174466b2672(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.c22ffb01fe96cd5baf6a4174466b2672(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _062b0e17b0b265231ad33ece1785b1fe(brandId: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp._062b0e17b0b265231ad33ece1785b1fe(brandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _0fd985657bea3b2f3a919bdc16fec5b9(id: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp._0fd985657bea3b2f3a919bdc16fec5b9(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Category ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _2aeef67a0c5f4a9161985387cab71ccc(brandId: number, id: number, category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp._2aeef67a0c5f4a9161985387cab71ccc(brandId, id, category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _8a437c9b58cb5726b37615e8a5a9857c(brandId: number, category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp._8a437c9b58cb5726b37615e8a5a9857c(brandId, category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        c22ffb01fe96cd5baf6a4174466b2672(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.c22ffb01fe96cd5baf6a4174466b2672(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @param {number} brandId Brand ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _062b0e17b0b265231ad33ece1785b1fe(brandId: number, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._062b0e17b0b265231ad33ece1785b1fe(brandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _0fd985657bea3b2f3a919bdc16fec5b9(id: number, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._0fd985657bea3b2f3a919bdc16fec5b9(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} brandId Brand ID
     * @param {number} id Category ID
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _2aeef67a0c5f4a9161985387cab71ccc(brandId: number, id: number, category: Category, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._2aeef67a0c5f4a9161985387cab71ccc(brandId, id, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} brandId Brand ID
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public _8a437c9b58cb5726b37615e8a5a9857c(brandId: number, category: Category, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration)._8a437c9b58cb5726b37615e8a5a9857c(brandId, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public c22ffb01fe96cd5baf6a4174466b2672(id: number, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).c22ffb01fe96cd5baf6a4174466b2672(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HUSAAPIsApi - axios parameter creator
 * @export
 */
export const HUSAAPIsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d0f15b1af046a8e16188381fef27782f: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getCategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchPage: async (string: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'string' is not null or undefined
            assertParamExists('doSearchPage', 'string', string)
            const localVarPath = `/husa/searchPage/{string}`
                .replace(`{${"string"}}`, encodeURIComponent(String(string)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getPosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} blockId Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockInfo: async (blockId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('getBlockInfo', 'blockId', blockId)
            const localVarPath = `/husa/getBlockInfo/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByCategoryId: async (categoryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getBlocksByCategoryId', 'categoryId', categoryId)
            const localVarPath = `/husa/getBlocksByCategoryId/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByPageId: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getBlocksByPageId', 'pageId', pageId)
            const localVarPath = `/husa/getBlocksByPageId/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} modelId Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDynamicPages: async (modelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getDynamicPages', 'modelId', modelId)
            const localVarPath = `/husa/getDynamicPages/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenuList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getMenus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageForTest: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getPageForTest', 'pageId', pageId)
            const localVarPath = `/husa/test/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageInfo: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getPageInfo', 'pageId', pageId)
            const localVarPath = `/husa/getPageInfo/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} postId Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById: async (postId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('getPostById', 'postId', postId)
            const localVarPath = `/husa/getPostInfo/{postId}`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo: async (productId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductInfo', 'productId', productId)
            const localVarPath = `/husa/getProductInfo/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getProducts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getRedirects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticPages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getStaticPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} tempId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateInfo: async (tempId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tempId' is not null or undefined
            assertParamExists('getTemplateInfo', 'tempId', tempId)
            const localVarPath = `/husa/getTemplateInfo/{tempId}`
                .replace(`{${"tempId"}}`, encodeURIComponent(String(tempId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/getTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [categoryId] Category ID
         * @param {string} [string] string
         * @param {string} [condition] condition: or/and, default: or
         * @param {Array<string>} [filters] filters array
         * @param {string} [sort] sort by newest / oldest
         * @param {string} [type] page type: product or support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProductByCategoryId: async (categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/husa/searchProduct`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (string !== undefined) {
                localVarQueryParameter['string'] = string;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (filters) {
                localVarQueryParameter['filters[]'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HUSAAPIsApi - functional programming interface
 * @export
 */
export const HUSAAPIsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HUSAAPIsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async d0f15b1af046a8e16188381fef27782f(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.d0f15b1af046a8e16188381fef27782f(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doSearchPage(string: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doSearchPage(string, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPosts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPosts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} blockId Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockInfo(blockId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockInfo(blockId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlocksByCategoryId(categoryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlocksByCategoryId(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlocksByPageId(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlocksByPageId(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} modelId Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDynamicPages(modelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDynamicPages(modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMenuList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMenuList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageForTest(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageForTest(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageInfo(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageInfo(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} postId Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostById(postId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostById(postId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductInfo(productId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductInfo(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRedirectList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRedirectList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStaticPages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStaticPages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} tempId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateInfo(tempId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateInfo(tempId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplateList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplateList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [categoryId] Category ID
         * @param {string} [string] string
         * @param {string} [condition] condition: or/and, default: or
         * @param {Array<string>} [filters] filters array
         * @param {string} [sort] sort by newest / oldest
         * @param {string} [type] page type: product or support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchProductByCategoryId(categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchProductByCategoryId(categoryId, string, condition, filters, sort, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HUSAAPIsApi - factory interface
 * @export
 */
export const HUSAAPIsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HUSAAPIsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        d0f15b1af046a8e16188381fef27782f(options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.d0f15b1af046a8e16188381fef27782f(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} string string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doSearchPage(string: string, options?: any): AxiosPromise<void> {
            return localVarFp.doSearchPage(string, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPages(options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.getAllPages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts(options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.getAllPosts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} blockId Block ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockInfo(blockId: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getBlockInfo(blockId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByCategoryId(categoryId: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getBlocksByCategoryId(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocksByPageId(pageId: number, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.getBlocksByPageId(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} modelId Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDynamicPages(modelId: number, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.getDynamicPages(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenuList(options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.getMenuList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageForTest(pageId: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getPageForTest(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageInfo(pageId: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getPageInfo(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} postId Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostById(postId: number, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.getPostById(postId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} productId Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfo(productId: number, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.getProductInfo(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductList(options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.getProductList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectList(options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.getRedirectList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingList(options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.getSettingList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticPages(options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.getStaticPages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} tempId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateInfo(tempId: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.getTemplateInfo(tempId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplateList(options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.getTemplateList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [categoryId] Category ID
         * @param {string} [string] string
         * @param {string} [condition] condition: or/and, default: or
         * @param {Array<string>} [filters] filters array
         * @param {string} [sort] sort by newest / oldest
         * @param {string} [type] page type: product or support
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProductByCategoryId(categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.searchProductByCategoryId(categoryId, string, condition, filters, sort, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HUSAAPIsApi - object-oriented interface
 * @export
 * @class HUSAAPIsApi
 * @extends {BaseAPI}
 */
export class HUSAAPIsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public d0f15b1af046a8e16188381fef27782f(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).d0f15b1af046a8e16188381fef27782f(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} string string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public doSearchPage(string: string, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).doSearchPage(string, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getAllPages(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getAllPages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getAllPosts(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getAllPosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} blockId Block ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getBlockInfo(blockId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getBlockInfo(blockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} categoryId Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getBlocksByCategoryId(categoryId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getBlocksByCategoryId(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getBlocksByPageId(pageId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getBlocksByPageId(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} modelId Model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getDynamicPages(modelId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getDynamicPages(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getMenuList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getMenuList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getPageForTest(pageId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getPageForTest(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getPageInfo(pageId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getPageInfo(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} postId Post ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getPostById(postId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getPostById(postId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} productId Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getProductInfo(productId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getProductInfo(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getProductList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getProductList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getRedirectList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getRedirectList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getSettingList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getSettingList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getStaticPages(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getStaticPages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} tempId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getTemplateInfo(tempId: number, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getTemplateInfo(tempId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public getTemplateList(options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).getTemplateList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [categoryId] Category ID
     * @param {string} [string] string
     * @param {string} [condition] condition: or/and, default: or
     * @param {Array<string>} [filters] filters array
     * @param {string} [sort] sort by newest / oldest
     * @param {string} [type] page type: product or support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HUSAAPIsApi
     */
    public searchProductByCategoryId(categoryId?: number, string?: string, condition?: string, filters?: Array<string>, sort?: string, type?: string, options?: AxiosRequestConfig) {
        return HUSAAPIsApiFp(this.configuration).searchProductByCategoryId(categoryId, string, condition, filters, sort, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HistoryApi - axios parameter creator
 * @export
 */
export const HistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHistories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/getHistories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} modelName Model Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoriesByModelName: async (modelName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getHistoriesByModelName', 'modelName', modelName)
            const localVarPath = `/history/getHistories/{modelName}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} modelName Model Name
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryByModelNameModelId: async (modelName: string, modelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getHistoryByModelNameModelId', 'modelName', modelName)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getHistoryByModelNameModelId', 'modelId', modelId)
            const localVarPath = `/history/getHistory/{modelName}/{modelId}`
                .replace(`{${"modelName"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HistoryRequest} historyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTitleUpdate: async (historyRequest: HistoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'historyRequest' is not null or undefined
            assertParamExists('historyTitleUpdate', 'historyRequest', historyRequest)
            const localVarPath = `/history/titleUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(historyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id History ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHistory: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showHistory', 'id', id)
            const localVarPath = `/history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HistoryApi - functional programming interface
 * @export
 */
export const HistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllHistories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllHistories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} modelName Model Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoriesByModelName(modelName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoriesByModelName(modelName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} modelName Model Name
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoryByModelNameModelId(modelName: string, modelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoryByModelNameModelId(modelName, modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {HistoryRequest} historyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historyTitleUpdate(historyRequest: HistoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.historyTitleUpdate(historyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id History ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHistory(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHistory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HistoryApi - factory interface
 * @export
 */
export const HistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HistoryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllHistories(options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.getAllHistories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} modelName Model Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoriesByModelName(modelName: string, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.getHistoriesByModelName(modelName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} modelName Model Name
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoryByModelNameModelId(modelName: string, modelId: number, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.getHistoryByModelNameModelId(modelName, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HistoryRequest} historyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyTitleUpdate(historyRequest: HistoryRequest, options?: any): AxiosPromise<any> {
            return localVarFp.historyTitleUpdate(historyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id History ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHistory(id: number, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.showHistory(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HistoryApi - object-oriented interface
 * @export
 * @class HistoryApi
 * @extends {BaseAPI}
 */
export class HistoryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getAllHistories(options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getAllHistories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} modelName Model Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getHistoriesByModelName(modelName: string, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getHistoriesByModelName(modelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} modelName Model Name
     * @param {number} modelId Model Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public getHistoryByModelNameModelId(modelName: string, modelId: number, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).getHistoryByModelNameModelId(modelName, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HistoryRequest} historyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public historyTitleUpdate(historyRequest: HistoryRequest, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).historyTitleUpdate(historyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id History ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HistoryApi
     */
    public showHistory(id: number, options?: AxiosRequestConfig) {
        return HistoryApiFp(this.configuration).showHistory(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MenuApi - axios parameter creator
 * @export
 */
export const MenuApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Menu} menu 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMenu: async (menu: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menu' is not null or undefined
            assertParamExists('addMenu', 'menu', menu)
            const localVarPath = `/menu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMenu: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMenu', 'id', id)
            const localVarPath = `/menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenu: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMenu', 'id', id)
            const localVarPath = `/menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/menu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {Menu} menu 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMenu: async (id: number, menu: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMenu', 'id', id)
            // verify required parameter 'menu' is not null or undefined
            assertParamExists('updateMenu', 'menu', menu)
            const localVarPath = `/menu/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MenuApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Menu} menu 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMenu(menu: Menu, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMenu(menu, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMenu(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMenu(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMenu(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMenu(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async menuList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.menuList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {Menu} menu 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMenu(id: number, menu: Menu, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMenu(id, menu, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MenuApiFp(configuration)
    return {
        /**
         * 
         * @param {Menu} menu 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMenu(menu: Menu, options?: any): AxiosPromise<Menu> {
            return localVarFp.addMenu(menu, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMenu(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteMenu(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMenu(id: number, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.getMenu(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menuList(options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.menuList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Menu ID
         * @param {Menu} menu 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMenu(id: number, menu: Menu, options?: any): AxiosPromise<Menu> {
            return localVarFp.updateMenu(id, menu, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI {
    /**
     * 
     * @param {Menu} menu 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public addMenu(menu: Menu, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).addMenu(menu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Menu ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public deleteMenu(id: number, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).deleteMenu(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Menu ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public getMenu(id: number, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).getMenu(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public menuList(options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).menuList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Menu ID
     * @param {Menu} menu 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public updateMenu(id: number, menu: Menu, options?: AxiosRequestConfig) {
        return MenuApiFp(this.configuration).updateMenu(id, menu, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotification', 'id', id)
            const localVarPath = `/notification/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNotification: async (notification: Notification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('importNotification', 'notification', notification)
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNotification: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showNotification', 'id', id)
            const localVarPath = `/notification/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Notification ID
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (id: number, notification: Notification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNotification', 'id', id)
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('updateNotification', 'notification', notification)
            const localVarPath = `/notification/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importNotification(notification: Notification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNotification(notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showNotification(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Notification ID
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(id: number, notification: Notification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(id, notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNotification(notification: Notification, options?: any): AxiosPromise<Notification> {
            return localVarFp.importNotification(notification, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationList(options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.notificationList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNotification(id: number, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.showNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Notification ID
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(id: number, notification: Notification, options?: any): AxiosPromise<Notification> {
            return localVarFp.updateNotification(id, notification, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @param {number} id Notification ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public deleteNotification(id: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).deleteNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Notification} notification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public importNotification(notification: Notification, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).importNotification(notification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public notificationList(options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notificationList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Notification ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public showNotification(id: number, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).showNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Notification ID
     * @param {Notification} notification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public updateNotification(id: number, notification: Notification, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).updateNotification(id, notification, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PageApi - axios parameter creator
 * @export
 */
export const PageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPage: async (brandId: number, page: Page, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('addPage', 'brandId', brandId)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('addPage', 'page', page)
            const localVarPath = `/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(page, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePage', 'id', id)
            const localVarPath = `/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doDeploy: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/page/doDeploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListAllPages: async (brandId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('getListAllPages', 'brandId', brandId)
            const localVarPath = `/page/getSummaryPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDynamicPage: async (brandId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('getListDynamicPage', 'brandId', brandId)
            const localVarPath = `/page/getDynamicPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getPage', 'pageId', pageId)
            const localVarPath = `/page/getPage/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} modelType Model Type
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageByModelTypeModelId: async (modelType: string, modelId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelType' is not null or undefined
            assertParamExists('getPageByModelTypeModelId', 'modelType', modelType)
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getPageByModelTypeModelId', 'modelId', modelId)
            const localVarPath = `/page/getPage/{modelType}/{modelId}`
                .replace(`{${"modelType"}}`, encodeURIComponent(String(modelType)))
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageDraft: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPageDraft', 'id', id)
            const localVarPath = `/page/getPageDraft/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductRoutes: async (brandId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('getProductRoutes', 'brandId', brandId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductRoutes', 'id', id)
            const localVarPath = `/page/getProductRoutes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockPage: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('lockPage', 'pageId', pageId)
            const localVarPath = `/page/lock/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageList: async (brandId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('pageList', 'brandId', brandId)
            const localVarPath = `/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showPage', 'id', id)
            const localVarPath = `/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unLockPage: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('unLockPage', 'pageId', pageId)
            const localVarPath = `/page/unLock/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Page ID
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage: async (brandId: number, id: number, page: Page, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brandId' is not null or undefined
            assertParamExists('updatePage', 'brandId', brandId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePage', 'id', id)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('updatePage', 'page', page)
            const localVarPath = `/page/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brandId !== undefined && brandId !== null) {
                localVarHeaderParameter['BrandId'] = String(JSON.stringify(brandId));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(page, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {Draft} draft 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageDraft: async (pageId: number, draft: Draft, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('updatePageDraft', 'pageId', pageId)
            // verify required parameter 'draft' is not null or undefined
            assertParamExists('updatePageDraft', 'draft', draft)
            const localVarPath = `/page/saveDraft/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(draft, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {Widgets} widgets 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageWidgets: async (pageId: number, widgets: Widgets, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('updatePageWidgets', 'pageId', pageId)
            // verify required parameter 'widgets' is not null or undefined
            assertParamExists('updatePageWidgets', 'widgets', widgets)
            const localVarPath = `/page/saveWidgets/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(widgets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPage(brandId: number, page: Page, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPage(brandId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doDeploy(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doDeploy(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListAllPages(brandId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListAllPages(brandId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListDynamicPage(brandId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListDynamicPage(brandId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPage(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPage(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} modelType Model Type
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageByModelTypeModelId(modelType: string, modelId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageByModelTypeModelId(modelType, modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPageDraft(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPageDraft(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductRoutes(brandId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductRoutes(brandId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockPage(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockPage(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageList(brandId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageList(brandId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showPage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showPage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unLockPage(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unLockPage(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Page ID
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePage(brandId: number, id: number, page: Page, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePage(brandId, id, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {Draft} draft 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePageDraft(pageId: number, draft: Draft, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePageDraft(pageId, draft, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {Widgets} widgets 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePageWidgets(pageId: number, widgets: Widgets, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePageWidgets(pageId, widgets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageApiFp(configuration)
    return {
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPage(brandId: number, page: Page, options?: any): AxiosPromise<Page> {
            return localVarFp.addPage(brandId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deletePage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doDeploy(options?: any): AxiosPromise<any> {
            return localVarFp.doDeploy(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListAllPages(brandId: number, options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.getListAllPages(brandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDynamicPage(brandId: number, options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.getListDynamicPage(brandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage(pageId: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getPage(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} modelType Model Type
         * @param {number} modelId Model Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageByModelTypeModelId(modelType: string, modelId: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getPageByModelTypeModelId(modelType, modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageDraft(id: number, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.getPageDraft(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductRoutes(brandId: number, id: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.getProductRoutes(brandId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockPage(pageId: number, options?: any): AxiosPromise<any> {
            return localVarFp.lockPage(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageList(brandId: number, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.pageList(brandId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPage(id: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.showPage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unLockPage(pageId: number, options?: any): AxiosPromise<any> {
            return localVarFp.unLockPage(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} brandId Brand ID
         * @param {number} id Page ID
         * @param {Page} page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage(brandId: number, id: number, page: Page, options?: any): AxiosPromise<Page> {
            return localVarFp.updatePage(brandId, id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {Draft} draft 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageDraft(pageId: number, draft: Draft, options?: any): AxiosPromise<any> {
            return localVarFp.updatePageDraft(pageId, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {Widgets} widgets 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageWidgets(pageId: number, widgets: Widgets, options?: any): AxiosPromise<any> {
            return localVarFp.updatePageWidgets(pageId, widgets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI {
    /**
     * 
     * @param {number} brandId Brand ID
     * @param {Page} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public addPage(brandId: number, page: Page, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).addPage(brandId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public deletePage(id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).deletePage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public doDeploy(options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).doDeploy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} brandId Brand ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getListAllPages(brandId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getListAllPages(brandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} brandId Brand ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getListDynamicPage(brandId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getListDynamicPage(brandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getPage(pageId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getPage(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} modelType Model Type
     * @param {number} modelId Model Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getPageByModelTypeModelId(modelType: string, modelId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getPageByModelTypeModelId(modelType, modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getPageDraft(id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getPageDraft(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} brandId Brand ID
     * @param {number} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public getProductRoutes(brandId: number, id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).getProductRoutes(brandId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public lockPage(pageId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).lockPage(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} brandId Brand ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public pageList(brandId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).pageList(brandId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public showPage(id: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).showPage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public unLockPage(pageId: number, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).unLockPage(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} brandId Brand ID
     * @param {number} id Page ID
     * @param {Page} page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePage(brandId: number, id: number, page: Page, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).updatePage(brandId, id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {Draft} draft 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePageDraft(pageId: number, draft: Draft, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).updatePageDraft(pageId, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {Widgets} widgets 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePageWidgets(pageId: number, widgets: Widgets, options?: AxiosRequestConfig) {
        return PageApiFp(this.configuration).updatePageWidgets(pageId, widgets, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostApi - axios parameter creator
 * @export
 */
export const PostApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPost: async (post: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            assertParamExists('addPost', 'post', post)
            const localVarPath = `/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePost', 'id', id)
            const localVarPath = `/post/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPost', 'id', id)
            const localVarPath = `/post/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByCategoryId: async (categoryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getPostsByCategoryId', 'categoryId', categoryId)
            const localVarPath = `/post/getPostsByCategoryId/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost: async (id: number, post: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePost', 'id', id)
            // verify required parameter 'post' is not null or undefined
            assertParamExists('updatePost', 'post', post)
            const localVarPath = `/post/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostApi - functional programming interface
 * @export
 */
export const PostApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPost(post: Post, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPost(post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostsByCategoryId(categoryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsByCategoryId(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePost(id: number, post: Post, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(id, post, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PostApi - factory interface
 * @export
 */
export const PostApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostApiFp(configuration)
    return {
        /**
         * 
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPost(post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.addPost(post, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deletePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPost(id: number, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.getPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} categoryId Category ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByCategoryId(categoryId: number, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.getPostsByCategoryId(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postList(options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.postList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Post ID
         * @param {Post} post 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost(id: number, post: Post, options?: any): AxiosPromise<Post> {
            return localVarFp.updatePost(id, post, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostApi - object-oriented interface
 * @export
 * @class PostApi
 * @extends {BaseAPI}
 */
export class PostApi extends BaseAPI {
    /**
     * 
     * @param {Post} post 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public addPost(post: Post, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).addPost(post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Post ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public deletePost(id: number, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).deletePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Post ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getPost(id: number, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} categoryId Category ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public getPostsByCategoryId(categoryId: number, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).getPostsByCategoryId(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public postList(options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).postList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Post ID
     * @param {Post} post 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public updatePost(id: number, post: Post, options?: AxiosRequestConfig) {
        return PostApiFp(this.configuration).updatePost(id, post, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct: async (product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('addProduct', 'product', product)
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: number, product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('updateProduct', 'product', product)
            const localVarPath = `/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProduct(product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProduct(product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: number, product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.addProduct(product, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: number, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.getProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productList(options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.productList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Product ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.updateProduct(id, product, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addProduct(product: Product, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).addProduct(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProduct(id: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProduct(id: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productList(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Product ID
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProduct(id: number, product: Product, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).updateProduct(id, product, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RedirectApi - axios parameter creator
 * @export
 */
export const RedirectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Redirect} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRedirect: async (redirect: Redirect, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirect' is not null or undefined
            assertParamExists('addRedirect', 'redirect', redirect)
            const localVarPath = `/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redirect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRedirect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRedirect', 'id', id)
            const localVarPath = `/redirect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRedirect', 'id', id)
            const localVarPath = `/redirect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectsByPageId: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('getRedirectsByPageId', 'pageId', pageId)
            const localVarPath = `/redirect/getRedirects/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {Redirect} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRedirect: async (id: number, redirect: Redirect, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRedirect', 'id', id)
            // verify required parameter 'redirect' is not null or undefined
            assertParamExists('updateRedirect', 'redirect', redirect)
            const localVarPath = `/redirect/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(redirect, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RedirectApi - functional programming interface
 * @export
 */
export const RedirectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RedirectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Redirect} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRedirect(redirect: Redirect, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Redirect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRedirect(redirect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRedirect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRedirect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRedirect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRedirect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRedirectsByPageId(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRedirectsByPageId(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {Redirect} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRedirect(id: number, redirect: Redirect, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Redirect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRedirect(id, redirect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RedirectApi - factory interface
 * @export
 */
export const RedirectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RedirectApiFp(configuration)
    return {
        /**
         * 
         * @param {Redirect} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRedirect(redirect: Redirect, options?: any): AxiosPromise<Redirect> {
            return localVarFp.addRedirect(redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRedirect(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteRedirect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirect(id: number, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.getRedirect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId Page ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedirectsByPageId(pageId: number, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.getRedirectsByPageId(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectList(options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.redirectList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Redirect ID
         * @param {Redirect} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRedirect(id: number, redirect: Redirect, options?: any): AxiosPromise<Redirect> {
            return localVarFp.updateRedirect(id, redirect, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RedirectApi - object-oriented interface
 * @export
 * @class RedirectApi
 * @extends {BaseAPI}
 */
export class RedirectApi extends BaseAPI {
    /**
     * 
     * @param {Redirect} redirect 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public addRedirect(redirect: Redirect, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).addRedirect(redirect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Redirect ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public deleteRedirect(id: number, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).deleteRedirect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Redirect ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public getRedirect(id: number, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).getRedirect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId Page ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public getRedirectsByPageId(pageId: number, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).getRedirectsByPageId(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public redirectList(options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).redirectList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Redirect ID
     * @param {Redirect} redirect 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedirectApi
     */
    public updateRedirect(id: number, redirect: Redirect, options?: AxiosRequestConfig) {
        return RedirectApiFp(this.configuration).updateRedirect(id, redirect, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SectionApi - axios parameter creator
 * @export
 */
export const SectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Section} section 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSection: async (section: Section, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'section' is not null or undefined
            assertParamExists('addSection', 'section', section)
            const localVarPath = `/section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(section, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSection: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSection', 'id', id)
            const localVarPath = `/section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSection', 'id', id)
            const localVarPath = `/section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sectionList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {Section} section 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSection: async (id: number, section: Section, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSection', 'id', id)
            // verify required parameter 'section' is not null or undefined
            assertParamExists('updateSection', 'section', section)
            const localVarPath = `/section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(section, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SectionApi - functional programming interface
 * @export
 */
export const SectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Section} section 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSection(section: Section, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSection(section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSection(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSection(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sectionList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sectionList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {Section} section 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSection(id: number, section: Section, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Section>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSection(id, section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SectionApi - factory interface
 * @export
 */
export const SectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SectionApiFp(configuration)
    return {
        /**
         * 
         * @param {Section} section 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSection(section: Section, options?: any): AxiosPromise<Section> {
            return localVarFp.addSection(section, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSection(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSection(id: number, options?: any): AxiosPromise<InlineResponse20027> {
            return localVarFp.getSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sectionList(options?: any): AxiosPromise<InlineResponse20026> {
            return localVarFp.sectionList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Section ID
         * @param {Section} section 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSection(id: number, section: Section, options?: any): AxiosPromise<Section> {
            return localVarFp.updateSection(id, section, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SectionApi - object-oriented interface
 * @export
 * @class SectionApi
 * @extends {BaseAPI}
 */
export class SectionApi extends BaseAPI {
    /**
     * 
     * @param {Section} section 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public addSection(section: Section, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).addSection(section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Section ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public deleteSection(id: number, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).deleteSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Section ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public getSection(id: number, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).getSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public sectionList(options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).sectionList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Section ID
     * @param {Section} section 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SectionApi
     */
    public updateSection(id: number, section: Section, options?: AxiosRequestConfig) {
        return SectionApiFp(this.configuration).updateSection(id, section, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingApi - axios parameter creator
 * @export
 */
export const SettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSetting: async (setting: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('addSetting', 'setting', setting)
            const localVarPath = `/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSetting: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSetting', 'id', id)
            const localVarPath = `/setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSetting', 'id', id)
            const localVarPath = `/setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (id: number, setting: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSetting', 'id', id)
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('updateSetting', 'setting', setting)
            const localVarPath = `/setting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingApi - functional programming interface
 * @export
 */
export const SettingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSetting(setting: Setting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSetting(setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSetting(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSetting(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSetting(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSetting(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(id: number, setting: Setting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSetting(id, setting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingApi - factory interface
 * @export
 */
export const SettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingApiFp(configuration)
    return {
        /**
         * 
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSetting(setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.addSetting(setting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSetting(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteSetting(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetting(id: number, options?: any): AxiosPromise<InlineResponse20028> {
            return localVarFp.getSetting(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingList(options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.settingList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Setting ID
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(id: number, setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.updateSetting(id, setting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingApi - object-oriented interface
 * @export
 * @class SettingApi
 * @extends {BaseAPI}
 */
export class SettingApi extends BaseAPI {
    /**
     * 
     * @param {Setting} setting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public addSetting(setting: Setting, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).addSetting(setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Setting ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public deleteSetting(id: number, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).deleteSetting(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Setting ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public getSetting(id: number, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).getSetting(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public settingList(options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).settingList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Setting ID
     * @param {Setting} setting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public updateSetting(id: number, setting: Setting, options?: AxiosRequestConfig) {
        return SettingApiFp(this.configuration).updateSetting(id, setting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Template} template 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate: async (template: Template, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'template' is not null or undefined
            assertParamExists('addTemplate', 'template', template)
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(template, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTemplate', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTemplate', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {Template} template 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (id: number, template: Template, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTemplate', 'id', id)
            // verify required parameter 'template' is not null or undefined
            assertParamExists('updateTemplate', 'template', template)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(template, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Template} template 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTemplate(template: Template, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTemplate(template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {Template} template 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(id: number, template: Template, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(id, template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateApiFp(configuration)
    return {
        /**
         * 
         * @param {Template} template 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTemplate(template: Template, options?: any): AxiosPromise<Template> {
            return localVarFp.addTemplate(template, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.deleteTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(id: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.getTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.templateList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id Template ID
         * @param {Template} template 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(id: number, template: Template, options?: any): AxiosPromise<Template> {
            return localVarFp.updateTemplate(id, template, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * 
     * @param {Template} template 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public addTemplate(template: Template, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).addTemplate(template, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public deleteTemplate(id: number, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).deleteTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getTemplate(id: number, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).getTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public templateList(options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).templateList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id Template ID
     * @param {Template} template 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public updateTemplate(id: number, template: Template, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).updateTemplate(id, template, options).then((request) => request(this.axios, this.basePath));
    }
}


